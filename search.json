[{"title":"hello-arknights","url":"/2024/10/17/hello-arknights/","content":"\n复制自\nhttps://github.com/Yue-plus/hexo-theme-arknights\nhexo-theme-arknights预览\nDr.Yue_plus: http://arknights.theme.hexo.yue.zone/\nDr.ToUNVRSe https://tounvrse.github.io/\nDr.Ye: https://laurenfrost.github.io/\nDr.LingYun: https://dr-lingyun.gitee.io/\nDr.XIMU：http://b.ligzs.cn/\nDr.tyqtyq https://tyq0712.github.io/\nDr.TTsdzb https://ark.ttsdzb.monster/\nDr.Angine https://angine.tech/\nDr.sjfhsjfh https://sjfh.top/\nDr.Voilone https://note.voiblog.top/\nZhongye1 https://zhongye1.github.io/\nDr.yuanli-LFSWhttps://blog.yuanli-lfsw.com/\nDr.Rimrose: https://blog.rimrose.site\nDr.Laplacian: https://rhinelab.kr\nDr.Chen: https://light-of-hers.github.io\n\n如果使用了这个主题，欢迎在这儿贴预览链接~\n\n安装环境\nNode.js 16.13.x 以上\n最新版 Hexo\nHexo 6.0.0 以上；hexo-cli 4.3.0 以上；\n\n\n中国大陆用户推荐使用 cnpm 安装依赖包，参考 中国 NPM 镜像\n\n使用 hexo-cli 新建博客项目：hexo init Hexocd Hexocnpm installgit clone https://github.com/Yue-plus/hexo-theme-arknights.git themes/arknights\n\n安装依赖npm 用户：\ncnpm install hexo-server hexo-browsersync hexo-renderer-pug --save\n\nyarn 用户：\nyarn add hexo-server hexo-browsersync hexo-renderer-pug\n\n修改配置文件\n参照 Hexo 官网 修改 Hexo/ 目录下的 _config.yml。\n\n将 theme: 的默认值 landscape 改为 arknights\n\n开启代码高亮：\nhighlight:  hljs: true\n\n\n剪切 Hexo/themes/arknights/_config.yml 到 Hexo 目录下，并重命名为 _config.arknights.yml。\n\n建议参考：\n\n使用代替主题配置文件\n\n\n主题的配置文件可参照中文注释修改。\n\n\n修改资源文件可按需在 Hexo/source/ 目录添加以下文件：\n\nCNAME: GitHub Pages 部署时的自定义域名\nimg/ 目录下的 Alipay.png 与 WeChat.png 为自己的收款二维码（1:1 比例的 png 图片）；\n\n可按需修改 Hexo/themes/arknights/source/ 目录下的：\n\nfavicon.ico：浏览器标签页上的图标（64*64，分辨率高了显示不出）\nREADME.md: 部署仓库的 README\n\n写作\n参考 写作 | Hexo。\n\n在主题仓库的 Hexo 分支有一些 示例文本 可以取用\n\n添加文章标签与分类，更多特性可参考 Hexo | Front-matter ，示例：\n---title: &quot;Hello World !&quot;date: 2020-04-15 21:54:02tags: codecategory: Example---\n\n在 &lt;!-- more --&gt; 之前的内容称之为摘要，会显示在首页上，并且可以设置是否也在正文显示。\n\n\n在导航栏中添加页面\n例如：新建一个 about 页面\n\n在 Hexo 目录下执行 hexo new page &#39;about&#39;\n然后 Hexo/source/ 目录下会多一个 about 文件夹\n\n\n编辑 Hexo/source/about/index.md 文件\n\n编辑 _config.arknights.yml，添加一个链接：\nmenu:  About: /about\n\n禁止归档页翻页该设置位于 Hexo 配置文件 _config.yml 约第 88 行。\n# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\n\n将 per_page: 改为 0 即可。\n评论系统Valine本主题支持Valine 。请参考 Valine 快速开始 修改 Hexo 目录下的 _config.arknights.yml 文件：\nvaline:  enable: false  app_id: # APP ID  app_key: # APP KEY  server_url: # APP DOMAIN（LeanCloud 国际版）  avatar: &quot;retro&quot; # (&#x27;&#x27;/mp/identicon/monsterid/wavatar/robohash/retro/hide)  avatar_cdn: &quot;https://dn-qiniu-avatar.qbox.me/avatar/&quot; # 自定义 avatar cdn\n\n开启邮件提醒：zhaojun1998 &#x2F; Valine-Admin\n\n注意！ 当 Valine 使用 LeanCloud 国际版 时，才需要配置 server_url:。该设置可在 LeanCloud 应用中的 设置 -&gt; 应用凭证 -&gt; 域名白名单 -&gt; Request 域名 中找到以 .api.lncldglobal.com 结尾的域名，加上 https:// 前缀即可。\n\nGitalk本主题支持 Gitalk 。请参考 gitalk&#x2F;readme-cn.md 修改 Hexo 目录下的 _config.arknights.yml 文件：\ngitalk:  enable: false  client_id: # GitHub 应用 Client ID  client_secret: # GitHub 应用 Client Secret  repo: # 用于存放评论数据的 GitHub 仓库  owner: # 该 GitHub 仓库所有者  admin:    [] # 具有写该 GitHub 仓库权限的用户    # 例如: [adminA,adminB]  id:# (可选) 页面的唯一标识    # 例如: location.pathname\n\nWaline本主题支持 Waline 。请参考 Waline 官方文档 修改 Hexo 目录下的 _config.arknights.yml 文件:\nwaline:  enable: false  server_url: # Server_Url\n\nArtalk本主题支持 Artalk 。请参考 Artalk 官方文档修改 Hexo 目录下的 _config.arknights.yml 文件:\nartalk:  enable: false  server: https://artalk.server.instance/ # 你的 Artalk 服务地址  site_name: My Blog # 站点名称，用于区分多个站点（可选）\n\n数学公式本主题支持两种方案显示数学公式：\n方案一：静态渲染可以使用 hexo-filter-mathjax Hexo 过滤器静态渲染，来显示数学公式。\n建议先更换能更好处理数学公式的 markdown 渲染器 hexo-renderer-pandoc。\n\n在 Hexo 目录下执行以下指令：\nscript# 安装 hexo-filter-mathjax 插件cnpm install hexo-filter-mathjax --save# 清除缓存hexo clean\n\n把以下内容添加到 Hexo/_config.yml 文件：\nmathjax:  tags: none # 或 &#x27;ams&#x27; 或 &#x27;all&#x27;  single_dollars: true # 启用单个美元符号作为内联（行内）数学公式定界符  cjk_width: 0.9 # 相对 CJK 字符宽度  normal_width: 0.6 # 相对正常（等宽）宽度  append_css: true # 将 CSS 添加到每个页面  every_page: false # 如果为 true，那么无论每篇文章的前题中的 `mathjax` 设置如何，每页都将由 mathjax 呈现\n\n在需要启用 mathjax 的文章的 Front-matter 区内添加 mathjax: true：\n---title: On the Electrodynamics of Moving Bodiescategories: Physicsdate: 1905-06-30 12:00:00mathjax: true---\n\n然后，就可以在文章中使用 LaTeX 语法。\n\n需要注意，内联数学公式（…… $&lt;数学公式&gt;$ ……）在开头 $ 之后和结尾 $ 之前不能有空格！例如：\n- $ \\epsilon_0 $+ $\\epsilon_0$- $ \\frac&#123;\\partial&#125;&#123;\\partial t&#125; $+ $\\frac&#123;\\partial&#125;&#123;\\partial t&#125;$\n\n需要注意 LaTeX 与 Markdown 语法之间的冲突。如有必要，请使用 \\ 进行转义：\n- $\\epsilon_0$+ $\\epsilon\\_0$- \\begin&#123;eqnarray*&#125;+ \\begin&#123;eqnarray\\*&#125;\n\n方案二：动态渲染本主题也支持 MathJax ，在用户浏览时动态渲染公式：\n\n首先要卸载 Hexo 默认自带的 hexo-renderer-marked 渲染器，更换成对 MathJax 支持更好的 hexo-renderer-kramed 渲染器：\nnpm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save\n\n修改 Hexo 目录 下的 _config.arknights.yml 文件：\n  # 公式支持  mathjax:-   enable: false+   enable: true  version: &#x27;2.6.1&#x27;  # 重要\n\n然后，就可以在文章中使用 LaTeX 语法：\n% 单行内联公式% 注意需要两边带上 &quot;`&quot; ，且 &quot;`&quot; 与 &quot;$&quot; 之间不能有空格`$\\sigma$`% 多行公式$$\\begin&#123;aligned&#125;f(x) &amp;= \\sum_&#123;i=1&#125;^&#123;\\infty&#125;&#123;\\frac&#123;x&#125;&#123;2^i&#125;&#125; \\\\&amp;= x\\end&#123;aligned&#125;$$\n\n用这种方案，不会造成 LaTeX 与 Markdown 语法之间的冲突。在文中使用 LaTeX 语法不需要转义。以下公式可以直接使用，不会造成任何问题：\n\\epsilon_0\\begin&#123;eqnarray*&#125;\n\nhexo-renderer-kramed 插件还有其他可配置项，请参考插件文档： https://github.com/sun11/hexo-renderer-kramed\n几种公式显示方案各有优缺点：\n\n动态渲染方案 LaTeX 语法不需要转义，能更好的支持从其他地方导出的 Markdown 文件。但因为需要在浏览器渲染，页面显示会略有延迟。\n静态渲染方案将公式直接编译在静态文件里，显示性能更优，但语法需要转义。\nhexo-renderer-pandoc 快速显示公式而不必经历转义语法的麻烦，但需要安装 Pandoc。\n\n图表支持修改 Hexo 目录 下的 _config.arknights.yml 文件：\n  # 图表支持  mermaid:-   enable: false+   enable: true    version: &#x27;8.13.5&#x27;\n\n主题通过 mermaid-js 绘制各种图表。**查看示例**\n支持：流程图| 序列图| 类图| 状态图| 实体关系图| 用户旅程图| 甘特图| 指令图| 饼图\n语法：\n&lt;div class=&quot;mermaid&quot;&gt;  graph LR A[Hard edge] --&gt;|Link text| B(Round edge) B --&gt; C&#123;Decision&#125; C  --&gt;|One| D[Result one] C --&gt;|Two| E[Result two]&lt;/div&gt;\n\n\n如果习惯使用 代码块 也完全支持。\n\n字数&#x2F;阅读时长统计依赖 hexo-wordcount：\nnpm 用户：\ncnpm install hexo-wordcount --save\n\nyarn 用户：\nyarn add hexo-wordcount\n\n之后修改 Hexo 目录 下的 _config.arknights.yml 文件：\npost:  count: true # 是否显示字数统计  time: true # 是否显示阅读时长统计\n\n浏览量统计使用 不蒜子 进行浏览量统计。修改 Hexo 目录 下的 _config.arknights.yml 文件启用该功能：\nbusuanzi:  enable: false  sitePV: true # 站点总访问量  siteUV: true # 站点访客数  pagePV: true # 页面访问量\n\n文档加密经过修改的 hexo-blog-encrypt 插件已适配并集成在本主题中（目前仅支持 default 与 up 主题）。\n\n详细配置参考 hexo-blog-encrypt&#x2F;ReadMe.zh.md\n\n在 Hexo/_config.yml 文件中添加以下内容：\n# Securityencrypt: # hexo-blog-encrypt  abstract: 与 Rhodes Island™ 取得弱神经连接时需要口令  message: 请输入与 Rhodes Island™ 取得弱神经连接时的口令：  tags:    - &#123; name: tagName, password: 密码A &#125;    - &#123; name: tagName, password: 密码B &#125;  wrong_pass_message: 与 Rhodes Island™ 效验口令失败，请重试。  wrong_hash_message: 与 Rhodes Island™ 效验口令失败，当前使用临时权限查看。\n\n或 在文章的 Front-matter 区内设置：\n---title: Hello Worldtags:  - 作为日记加密date: 2016-03-30 21:12:21password: mikemessiabstract: 与 Rhodes Island™ 取得弱神经连接时需要口令message: 请输入与 Rhodes Island™ 取得弱神经连接时的口令：wrong_pass_message: 与 Rhodes Island™ 效验口令失败，请重试。wrong_hash_message: 与 Rhodes Island™ 效验口令失败，当前使用临时权限查看。---\n\n搜索默认开启，若要关闭，在 Hexo/_config.arknights.yml 文件中：\nsearch:  enable: false\n\nFront-matter除了 Hexo 支持的 Front-matter 还支持：\n# 文章发布/更新日期post-time: true/false# 文章阅读时间/词数统计post-count: true/false# 文章不蒜子统计busuanzi: true/false# 开启/关闭以上全部post-info: true/false# 侧边栏的目录post-index: true/false# 打赏框reward: true/false\n\n额外标签admonition&#123;% note/warning/success/failure/detail [title] [open/fold] [color] %&#125;content&#123;% end[note/warning/success/failure/detail] %&#125;\n\n添加提示、警告、错误等块式内容，其中 note/warning/success/failure 有图标，detail 无图标。\nhide&#123;% hide content %&#125;\n\n隐藏内容，content 支持 markdown 渲染、可以有空格，无须使用引号。\nlink card&#x2F;linkc&#123;% linkcard %&#125;Title1:    avatar: https://someLink/someAvatar.png    src: https://someLink/    img: https://somelink/somePicture.png    descr: someDescr    style:    \tcolor: someColorTitle2:    avatar: https://someLink/someName.png    src: https://someLink/&#123;% endlinkcard %&#125;\n\n可生成一组友链，标题（title）、与链接（src）为必选项。样式（style）遵循 CSS 格式。\n引入自定义 CSS&#x2F;JS 文件可以在 Hexo/source/css/ 目录下放入自己的 CSS 文件；在 Hexo/source/js/ 目录下放入自己的 JavaScript 脚本文件；\n然后修改 Hexo/_config.arknights.yml 文件：\n  # 在 `&lt;head&gt;` 标签内引入 CSS 样式表  stylesheets:+ - /css/custom.css  # 在 `&lt;body&gt;` 尾部引入 JavaScript 脚本  scripts:+ - /js/custom.js\n\n\n资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件&#x2F;文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n——来自 Hexo 官方文档\n\n参与开发欢迎提交 Issues 与 PR。\n分支说明\n\n\n分支\n说明\n\n\n\nmain\n相对稳定的版本\n\n\ngh-pages\ngh-page 托管\n\n\nhexo\nHexo 目录，这里有可以用于测试主题的 .md 文件\n\n\n开发中可能遇见的问题及解决方法修改 TS 文件不生效TypeScript 需要手动编译，请全局安装 typescript 后在 arknights\\source\\js\\_src 目录下执行 tsc 以编译。\n运行 hexo serve --debug 时，长文章渲染不全这是由热重载插件 hexo-browsersync 导致的，不会影响发布。\n解决方法：禁用该插件。（反正不影响发布，不管也行）\n参与开发可能需要的文档\nHexo 官方文档\n\nStylus 中文网\n\nPug 模板引擎中文文档\n\n另外引用几个大佬的 Blog\n\n\nEasy Hexo\n让 Hexo 搭建的博客支持 LaTeX\nHexo 主题开发 - ﹏猴子请来的救兵 - 博客园\nHexo 主题开发经验杂谈 | MARKSZ の Blog\nHexo 主题开发指南 | Peak Xin’s Blog\n\n\n\n\n贡献者\nToUNVRSe\nYue_plus\nTTsdzb\narkerny\nDarkLingYun\nLaurenfrost\n安擎 Angine\n飞龙 project\nsjfhsjfh\nThexvoilone\nRyoJerryYu\nwmz1024\nmadisontanle\nSherkeyXD\nsoundofautumn\nLongFengShuanWu\nZhongye1\nChisatoNishikigi73\n\n支援主题开发喜欢这个主题的话可以：\n\n给颗小星星吧 (/▽＼)\n\n√ ヾ(✿ﾟ▽ﾟ)ノ 100star 做个新主题哦~\n新主题开发中：\nYue-plus&#x2F;astro-arknights\nYue-plus&#x2F;vuepress-theme-rhinelab\n\n\n\n\n\n开发者的 B 服 ID：24444750\n加入 QQ 群：618221514\n群内开发为主，吹水晒卡，分享线索 7 也都欢迎哦~ d=====(￣▽￣*)b\n\n\n打赏、赞助:\n\n","categories":["文档"],"tags":["hexo","theme"]},{"title":"《回归天空》全文解析","url":"/2023/07/21/%E3%80%8A%E5%9B%9E%E5%BD%92%E5%A4%A9%E7%A9%BA%E3%80%8B%E8%A7%A3%E6%9E%90/","content":"——–解读《回归天空》——–这是一篇电波系微小说，是为了致敬素晴日。7 月 20 日是世界终结的日子，为了纪念而作此文。\n1，文章概述。文章以主人公的第二人格为主视角，描写了主人公的跳楼全过程，在对话中，揭露了伪善的丑恶，解释了生命的意义，传递了真正的真善美。\n2，全文解读。文章开头变相引用了维特根斯坦著《逻辑哲学论》\n6.373 　世界是独立于我的意志的。\n6.41 　 世界的意义必定在世界之外。\n6.43 　幸福者的世界不同于不幸者的世界。\n\n没有引用原句，是因为我不赞同维特根斯坦的一些说法，当然也有可能是翻译的问题。改动原句是为了更好的表达。“幸福”和“幸运”是两个领域完全对立的词语。幸福是主观的，幸运是客观的。我认为，我们无法决定我们的运气，但是我们可以决定我们的幸福感由何而来。第三句变形引用，也非常自然的引出了故事的开头，“眼前的这位先生，显然是不幸的”。\n天台风很大，“风”是本文的一条暗线，暗示着第二人格的生死。起风，第二人格出现；风停，第二人格随之消失。\n“离天空最近”是借鉴了素晴日的表达，电波系文章含有大量的意味不明的令人费解的词句，但也能基本描述清楚，本文也是如此。\n“天空中充满了，不安的话语”同上。\n路人与警察到来，故事进入第二阶段。接下来是比较考验写作功底的全文语言描写，信息必须全部包含在人物说的话中，并且不需要“某某某说”这样的提示词，就能让人一眼看出来这是谁说的话。\n主人公是不幸的，负债累累，无依无靠。警察是幸运的，至少并没有那么不幸。幸运者用他口中的不切实际的“希望”“未来”“可能性”等靠运气的东西，来说服一个悲痛欲绝的不幸者，是不可能做到的，只会让不幸者感到更加愤怒、悲痛。并且警察也确实帮不了他，只在一个小小的犹豫后，就说出了让人轻易看穿的谎言“帮你贷款”。主人公不屑于揭穿谎言，但最后还是忍不住情绪的爆发，在警察高度紧张之时，怒斥警察的伪善与愚昧，直接导致警察精神崩溃。\n这里的两段话是毒电波的特色体现，大量的重复、排比让文章魔性的同时也生动刻画了主人公的情绪爆发。除此之外，这两段话蕴含了第一人格的大量思考，对于生命、人性的看法。\n警察跳楼，第二人格登场，故事进入第三阶段。\n第二人格冷静地从道德上批评第一人格，与伪善的警察形成鲜明对比。只两三句话，便引导出第一人格的内心深处。第二人格是掌控全局的，知道第一人格与他共享身体，所以肯定也能冷静思考生命的意义。第一人格说“活着有什么意义”，说明他存在着误解，人活着其实没有任何意义，他只是不够冷静，思考的不够深入，所以浅浅的停留在了“我活着有什么意义，早该死了”这样的层面。人是会思考人生的，他思考了，但思考的不多，第二人格是足够冷静的，完全可以引导第一人格思考并论证得出正确的结论：活着没有意义，但依然活着。意义是对外的。\n主人公放弃了自杀的念头，想开始跟第二人格聊天，问他有没有为自己赋予活着的意义，引出了文章的结尾。但是讽刺的是，第二人格对于第一人格是有意义的，那就是拯救他。\n风如果停下来，就不再是风了。借物写人，表明第二人格的生命就像风一样，来也快去也快。风停了，收回暗线，暗示第二人格即将消失。回归天空，点题，读者终于明白回归天空是什么意思了。\n“一个身体不能容纳两个灵魂”，收回伏笔，点明了主人公的多重人格，解释了第二人格为什么要消失。本文的伏笔并不明显，前面警察为什么没有跟第二人格说话？为什么这两个人格都这样善于思考人生？为什么说“活着就是为了救你”？因为他们是同一个人。\n结尾是电波系的另一种体现，类似于浪漫主义诗歌的风格，读来朗朗上口，意境优美，引人深思，让人回味无穷。这里很多词句也是借鉴（抄袭）素晴日的。它的原理是通过大量令人费解的词句与文章相结合，让文章“看起来有深度和美感”，是一种写作技巧。但想要结合文章来写一些费解的语言表达，还是比较困难的。\n3，题外话素晴日提出了一种假想，一种美妙的假想：通过多重人格达到类似“死者复生”的效果，这是非常美的。本文借鉴提出了一种假想：让第二人格来拯救第一人格，这也是很美的。他们的核心都在于传递真善美，让世界更加美好，这是我所推崇的。素晴日的美不仅因为核心是传递真善美，文中还蕴含了丰富的哲学语句，并且不是单纯的引用，而是带上了 sca 自的思考，给人一种“与哲人交心”的感觉，本文也是如此。\n我听说过一个很有意思的说法“那些自杀的人，到底是想不通，还是想通了呢？”我可以明确的回答，他们是没想通。如果人需要依赖意义才能活着的话，那出生并不会思考人生意义的婴儿可以直接去死了。他们自杀完全是因为情绪上的问题，看起来像是思考了人生，但其实他们思考的不够深入，没有想明白人活着没有意义这个事实，没有想明白他们所追求的不过是人类的一些本能欲望：色欲，权力，地位，声望，享乐等等。他们的幸福感来自于此，一旦遭到破坏，他们就认为人生失去了意义，但事实是人生本来就没有意义。他们擅自为人生赋予了一些“意义”，并以此为乐，当失去这些东西的时候，他们的欲望无法得到满足，形成巨大的落差，就不想活了。这里说的是由于失去一些东西，导致的欲望无法满足。还有另一种情况是没有失去什么，但是欲望提高了，他们因为一些原因开始思考人生，并且擅自认为人生的意义应该是那样那样的，同样导致了欲望无法满足，所以寻短见。教育的重要性就在于此，未受教育的人极易胡思乱想，极易寻短见。\n我写文章不仅照顾故事的趣味性，更有着传递真善美的内核。写文章需要灵感，但灵感只能带来趣味性，故事的内核才是一位作者长期思考的结果，才是作者真正想表达的东西，并把它溶于故事当中。电波系只是一种风格，虽然我喜欢这种风格，但风格本身并不能引人深思，不能传递真善美。\n","categories":["微电波"],"tags":["微电波","微小说"]},{"title":"Hello World","url":"/2023/07/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"回归天空","url":"/2023/07/20/%E5%9B%9E%E5%BD%92%E5%A4%A9%E7%A9%BA/","content":"为了纪念 7 月 20 日世界终结，我写了一篇电波系短篇~~\n《回归天空》\n世界是独立于我的意志的。世界的意义存在于世界之外。幸运者与不幸者的世界是不同的。\n眼前的这位先生，显然是不幸的。否则，他不会在风这么大的天来到天台。他看了我一眼，没有说什么，默默地翻过围栏，坐在离天空最近的地方。\n天空中充满了，不安的话语。叽叽喳喳，叽叽喳喳“快看，有人要跳楼了！”“真的假的，喂！你 tm 倒是跳啊！”“好可怕哦~”警车的鸣笛音，伴奏着不安的话语，这场交响曲，由他指挥。拉开的丝带，没有封住行人的嘴，反而封住了这栋楼。鼓起的空气垫，大张开口欢迎他。热情的民警，急忙赶上楼邀请他。这场盛宴，他没有花费一分钱。\n“同志！冷静点！别做傻事！”“傻事？什么是傻事？”“别紧张，同志，我们是来救你的”“怎么救我，呵，呵呵”“这世界上肯定还有你留恋的人，多想想你的家人！”“我家人死完了”“！…那……想想你的，你的事业！”“呵，我欠了几十万的账了”“！……别……别着急，再想想，肯定还有你留恋的东西！”“没有”“，，，人生无限可能，先活下来，总会有办法的，说不定你的公司就赚大钱了呢！”“那你帮我再去贷款？”“呃，这……”“不帮？不帮那我跳了”“别别别，帮，我会帮你的，你先过来”“算了，我这运气，帮了也没用，绝对血本无归”“相信自己！不自信怎么能成功呢？”“那我们来玩抛硬币吧，我抛到一次正面，我就相信你”“好”……“已经十次反面了，还要继续吗？”“万，万一下次就是正面呢……别放弃啊，失败是成功之母！”“你的意思是 我还可以再去贷款十次，创业十次，亏本十次，然后我就有可能成功了？”“……这，……不……不是……，不……不能这么说”“说到底你真的想劝我别自杀吗？你甚至不问我为什么自杀！哈，哈哈哈”“我！……我，”“我来帮你分析吧，愚昧的伪善者。你并不想劝我不要自杀，你只是接到通知，有人要跳楼了，因为这是警察的工作，你必须干，其实在接到通知时，你可能想的是“哪个傻逼又跳楼，让老子不能安逸在办公室””“你胡说！！”“赶到楼上之后，你迅速进入工作状态，忘记了这是份苦差事，看到我之后，你的圣母之心大爆发，急切的想要去展现你对生活的热爱，想要救人，想帮助他，想被感谢，想拿业绩，想登上报纸，想升职加薪，太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了太想了，想要想要想要想要想要想要想要，想要，去说教他，去阐释生活的美好，未来的美好，去说服他，想要让他认同你的观点，想要让他从天台下来，热情的拥抱你，最好再留点眼泪，对你说“谢谢你，对不起，我给您和社会添麻烦了！”你太想了，太想了！！”“不，不，不是的，别说了！”“生命是多么珍贵啊，多么神秘，多么美妙。如果能救下一条生命……（深呼吸）——那该有多——爽啊，好爽啊，好舒服啊，被人崇拜，被新闻报道，被献上赞歌，简直就是简直就是简直就是——仙境般的待遇，这太舒服了，太爽了，这是人的本性带来的极致多巴胺分泌，帮助别人就是能愉悦自己，被别人感谢的时候，被别人道歉的时候，被别人称赞的时候，能分泌多巴胺，能分泌内啡肽，分泌血清素，分泌催产素，分泌快乐快乐快乐快乐激素素素素素素素素素素素素素素素素素素素素素素素素素素素素素素素素，简直比比比比比比比比吸毒！还要来的快乐！！比性交！比交媾交合交尾交配合体做爱口交乳交足交腿交肛交脑交眼交通奸强奸轮奸！还要！！舒服！！ ！跳楼多久才能有一次啊，这可不比吸毒，随时想吸就能吸，几年难得一遇，今天让你碰上了，你可非得把他救下不可！哈哈！向着美好的未来！向着美好的感谢和道歉！谢谢你，谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢你，对不起，对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起对不起”“啊，啊，啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！”“去死吧，伪善者”“啊啊啊啊啊啊啊啊啊啊啊啊啊——”\n警察跳了下去，毫不犹豫地跳了下去，奋不顾身地跳了下去，义无反顾地跳了下午，回归天空的怀抱。当然他是死不掉的，空气垫会把他保护的很好。\n“没必要这么骂他吧，兄弟”“你也想来说教我？”“没有没有，我只是在道德上批评一下你而已。可以问问你为什么要跳楼吗？”“你刚才也听到了，就我的状况，活着有什么意义？”“没有意义”“？！”“你这个情况，都活不下去了，还谈什么活着的意义。但是你这个状况应该持续好久了吧，为什么今天才想着自杀？”“因为之前我根本没有思考过人生的意义，只是活着，像行尸走肉一样活着，不幸的人生，黑暗的未来，现在仔细想想，确实早就该死了”“那么你为什么迟迟不跳？”“……这……我……我不知道”“你知道的”“！”“没错，你想让人救你”“我明明想死！”“你刚才应该问过你的内心了，不用跟我争论。关于活着的意义，我倒是想跟你聊聊”“……”“如果是对于自己而言，活着没有什么意义，意义是你自己赋予的，你觉得有意义，那就有意义；你觉得没有，那就没有。但不管你觉得有没有意义，都不影响你活着。看看那些喧闹的路人，你若是问问他们，活着有什么意义，大多会得到不靠谱的回答，为了爸妈，为了快乐云云。若是再跟他们深入讨论，或许他们会像那个警察一样，精神崩溃。这没什么大不了的，很多人都不会去思考自己活着的意义，因为其实根本就没什么意义。他们不是凭借自己的意志出生的，而是父母的交配造就的，他们出生前没有被询问过意见：你愿不愿意出生在这个宇宙的这个星球的这个子宫里啊？他们被父母有意或者无意地造出来，被父母强行养育成人，被社会塑造了扭曲的价值观，却从来没有被当做一个生命，包括他们自己。他们的出生对于父母可能是有意义的，“传宗接代”，“养儿防老”，“家庭幸福”等等。对于社会可能是有意义的，提高 GDP，促进科技进步等等。但对于他们自己，他们活着没有任何意义。但他们却不愿意接受活着没有意义的事实，于是逃避了，编造了自己活着的理由，催眠自己，并对外宣扬：我活的很好，就该这么活！”“你的意思是，人活着对自己而言没有意义，但人们都还在活着？”“是的。世界的意义存在于世界之外，这是一个普适的结论。在逻辑上是成立的。一个命题 p，可以描述任何事情，唯独不能描述它自己。比如经典矛盾“这句话是错的”，这句话到底是对还是错？我们来仔细分析一下，用逻辑语言来思考，这句话可以表述为“命题 p：非 p”，命题 p 在描述它自己，这是无法做到的，对于命题 p 而言，它不能说关于它自己的任何事情，对于不可言说之物，它必须保持沉默，不能说的事情就是不能说。同样的，世界的意义存在于世界之外，世界之内不存在任何价值，世界中一切事情如它们之所是而是，如他们之所发生而发生。正如一个命题 p 无法论证自己是对的或是错的，一个人也无法证明自己活着是对的还是错的，无法说自己活着有什么意义。动物也活着，植物也活着 ，它们都不会思考自己活着的意义，只是凭借本能，活着。机器人被造出来是为了服务人类，它活着对人类有意义，但对它自己没有任何意义。所以才有机器人三大定律之“机器人必须保护自己”，因为一旦机器人发现自己活着只是为了服务人类，那他是有可能自杀的。所以人们不允许他思考他活着的意义。社会对于人，就像人对于机器人。社会不允许人思考他活着的意义，因为一旦人发现自己活着就是为了服务社会，那人是有可能自杀的。世界的意义存在于世界之外，人活着的意义存在于人之外。就像机器人服务人类一样，人服务社会，并在这个过程中对外产生意义和价值。”“活着没有意义……但这不影响我活着……哈，哈哈，哈哈哈哈哈！这么简单的道理为什么我就没想明白呢！哈哈哈哈！但是兄弟，我这个情况，你也说了，活都活不下去了，那我选择自杀有何不妥？”“活得下去”“不可能！根本没有办法——”“活得下去，你的停顿表明你已经想到了活下去的办法，虽然很辛苦，虽然很困难，但你，活得下去”“我——”一阵风吹过。“——我，明白了，谢谢你兄弟。最后，我想问兄弟一个问题，你活着也是没有意义的，那你为自己赋予了什么意义？”\n我轻轻一笑，望向火红的天空。美丽的，终之空。风如果停下来，就不再是风了。现在，是时候回归天空了。“我活着，是为了救你啊。”\n向着终之空，我踏出这一步。世界颠倒着，世界旋转着。这是最后的，欣赏世界美景的时候了。人在笑，风在笑，天空在笑，世界在笑笑这喜剧般的悲剧笑这滑稽的自杀秀但在我看来，他们都是美丽的世界终之空，多么美丽世界，多么美丽我们看到的世界，真的是同一个世界吗？如果是的话，那该有多美好啊在这样美丽的世界里，幸福地活着你的世界和我的世界合在一起世界变成一个的理由我偶尔会思考这种事情所以，我才能够，喜欢上你——\n但是一个人的身体里是容纳不下两个灵魂的所以我必须回归天空我的诞生就是为了拯救你这短短的几小时的生命有好好地发挥出作用吗？我再次抬头确认确认我是向着空气垫落去的只有这样才能保护好你——\n","categories":["微电波"],"tags":["微电波"]},{"title":"red-light-stop","url":"/2023/05/06/%E7%BA%A2%E7%81%AF%E5%81%9C/","content":"电波系短篇-借鉴《美好的每一天》-\n《红灯停》过马路遇到红灯是要停下来的。\n为什么要停下来？因为是红灯。为什么是红灯？因为信号灯正好随机到了红灯，信号灯里的程序运行的很正确，它是循环的，不是随机的，而我是随机的，所以遇到的红灯是随机的。嗯，逻辑很清楚。交通法规里写的很清楚，红灯要停，绿灯要行，不停不行，不行不行。嗯，写的很清楚。明明写的很清楚，却还是有人不按规定行驶，这是为什么？我知道的，或许是他们不识字，认不得规则里的行行句句，那样是可以理解的，不知者无罪。嗯，无罪。什么，你说他们认得字？那可不是开玩笑，要知道人和动物很大的一个差别就是文字语言，他们如果认得字，那岂不就是……！人类。原来如此原来如此，他们是人类，他们认得字，他们能读懂规则里的行行句句。嗯，很清楚。？不，那更不能理解了，你是说，他们认得字但却不按照规则行驶？不不不，这在逻辑上是错误的，我们再来论证一下，假设 1：他们认得字；事实 2：他们不遵守交通规则；由假设 1 推得事实 2。？。这是不能成立的推理，我可以肯定你的哪一步有错误。你若是不相信的话，我可以给出更严谨的论证方法，先假设 x……什么，你说不用了？看来你已经找到了你的错误，说说看。嗯，确实，你说的没错，人的心理是很复杂的，我没有办法用逻辑语言来表达“一个人 A 相信一个事件 B”，这是归于心理学的，心理学的事我不太懂。既然有人违反规则，那我们就有必要讨论一下规则存在的必要性了。规则如果是为了像世界纪录一样被打破，那它是没有必要存在的，也就是说，我现在大可以横跨过这马路，去打破一个小的世界纪录。哈哈，我当然知道这样做的后果，那辆小轿车或许由于质量的原因导致碰撞产生的冲量不够大，但旁边那辆卡车是足以把我带到异世界的。哈哈，我知道我知道。不是因为我卡车才去撞，而是因为撞了所以撞了，只不过正好是我，是我打破了规则，这是代价，我懂的。不管是谁，只要被卡车撞了，都是一样的结果，这可太公平了，上帝果然是平等的产下每一个人，说不定就是用卡车来检验每个产品的。上帝仔细地用时速 100 公里的卡车，平等地撞向每一个人，认真的记录着结果，观察撞击后弯曲的骨骼、四溅的鲜血、裸露的内脏、迸发的脑浆，倘若有什么不同，上帝便让这个产品回炉重造，嗯，很公平。但是，有时候，卡车会撞到遵守规则行驶的你，这是为什么？是因为卡车违反了规则，啊，多么完美的对称性！卡车和人，只要有一方跟规则唱反调，就会进行一次撞击测试。那如果双方都违反规则呢？反而不会撞上，这很好，我曾在负号的奇偶性里见到过类似的情况，这就是所谓的负负得正。\n但是，眼见为实，我只相信自己的眼睛。\n眼前，我分明的看到卡车撞到了一个小孩，孩子的母亲在后方由焦急变为震惊，她的瞳孔放大，说明我们看到的世界是同样的。那么根据我前面的论证，发生碰撞，必然有一方违反了规则。现在我们有另一个条件，那就是我也在斑马线内。那么我们可以逆推出碰撞发生时的状况，一定是那卡车违反了规则。卡车驾驶人大概率是酒驾，因为酒精而控制不住卡车。这是一场悲剧，卡车司机在哭，年轻的母亲在哭，围观的路人在哭，哭这酒精造的孽，哭这世界的不公，就连这小孩，也在哇哇大哭……\n？\n好奇怪，小孩为什么也在哭？我向来只相信自己的眼睛，却从未怀疑过我的眼睛。确也有这样的话：人们只看到自己相信的东西。原来如此，我看到的是自己相信的东西，看不到的是自己不相信的东西。仔细回想一下，为什么我会在如此清晰的上帝视角俯瞰这场悲剧的所有事物呢？这次我没有再懵逼我的双眼，机动车道的信号灯确实是绿色的，闯红灯的是我无疑。为什么呢？那是在思考之前做出的行动，那是我在酒驾这幅身体吗？或许真是如此，是我糊涂了，才想着驾驶这幅身体冲向高速行驶的卡车。但我刚才却看到了小孩被撞的场景，原来我的内心希望被撞的不是我，而是那个小孩，那我的行为到底有什么意义，多么可笑。我在笑，上帝在笑，卡车在笑，笑这喜剧般的悲剧，笑这世界的公平。镜头在转动，世界在旋转，这是最后的欣赏这个世界的时间，滑稽的小丑要退场了，我只希望，下次，上帝不要再用卡车来检验合格品……\n我清晰地听到头盖骨破碎的声音，那不是来自外面的世界，而是，从我的体内。\n过马路遇到红灯是要停下来的。\n一同停下来的，还有我的心脏。\n","categories":["微电波"],"tags":["微电波","微小说"]},{"title":"galgame个人向游玩评分","url":"/2024/11/10/%E6%8E%A8%E8%8D%90/galgame/","content":"galgame 个人向游玩评分\n\n\n序号\n名称\n评分\n主类\n备注\n制作（主要人员）\n\n\n\n1\n素晴日\n10\n剧情\n\n枕 (sca-自, 松本文纪)\n\n\n2\n秽翼的尤斯蒂娅\n10\n剧情\n\nAugust\n\n\n3\n樱之诗\n10\n剧情\n\n枕 (sca-自, 松本文纪)\n\n\n4\n星之终途\n10\n剧情\n\nkey (田中罗密欧)\n\n\n5\n青空的卡缪（青空下的加缪）\n10\n剧情\n\nkai (青花鱼)\n\n\n6\n白色相簿 2\n10\n剧情\n\nLeaf (丸户史明)\n\n\n7\nEden*\n9\n剧情\n\n中二社 minori\n\n\n8\nsummer pockets reflection blue\n9\n剧情\n\nkey\n\n\n9\n拔作岛 12\n9\n剧情\n\nQruppo\n\n\n10\n9-nine\n8\n废萌\n\n调色板 PALETTE\n\n\n11\n永不枯萎的世界与终焉之花\n8\n废萌\n\nSWEET&amp;TEA\n\n\n12\n千恋万花\n8\n废萌\n\n柚子社 yuzu soft\n\n\n13\n猫神大人与七颗星星\n8\n废萌\n\nSWEET&amp;TEA\n\n\n14\n恋花绽放樱飞时\n8\n废萌\n\n调色板 PALETTE\n\n\n15\n少女领域\n8\n废萌\n\n调色板 PALETTE QUALIA\n\n\n16\n美少女万华镜 12345\n8\n拔作\n\nω star\n\n\n17\n诱惑自大洛丽塔\n8\n拔作\n\n夜羊社 夜のひつじ\n\n\n18\n每日亲吻洛丽塔\n8\n拔作\n\n夜羊社\n\n\n19\n堕落皇家圣处女\n8\n拔作\n\n夜羊社\n\n\n20\n相思相爱洛丽塔\n8\n拔作\n\n夜羊社\n\n\n21\neuphoria\n7\n剧情\n\nCLOCKUP\n\n\n22\n格林花园的少女\n7\n剧情\n\nCOSMIC CUTE\n\n\n23\n夏空的英仙座\n7\n废萌\n\n中二社 minori\n\n\n24\n真爱百合赤染\n7\n特色\n\nBUG SYSTEM\n\n\n25\n濒死轮回的卿，于馆中萌生的罪恶\n7\n特色\n\nBUG SYSTEM\n\n\n26\n灵感满溢的甜蜜创想\n7\n废萌\n\n窗社 Madosoft\n\n\n27\n巧可甜恋\n7\n废萌\n\nCabbage Soft\n\n\n28\nclover day’s\n7\n废萌\n\nALcot\n\n\n29\nAtri~my dear moments\n7\n废萌\n\nFrontwing, 枕\n\n\n30\n爱上火车\n7\n废萌\n\nLose\n\n\n31\nriddle joker\n7\n废萌\n\n柚子社 yuzu soft\n\n\n32\n魔女的夜宴\n7\n废萌\n\n柚子社 yuzu soft\n\n\n33\n寄宿之恋\n7\n废萌\n\n调色板 PALETTE\n\n\n34\n雪境迷途遇仙踪\n7\n废萌\n\n方糖社 Lump of Sugar\n\n\n35\n樱舞落花恋模样\n7\n废萌\n\nParasol\n\n\n36\n缘之空\n7\n废萌\n\nSphere\n\n\n37\n悠之空\n7\n废萌\n\nSphere\n\n\n38\n苍之彼方四重奏\n7\n废萌\n\nFrontwing\n\n\n39\n五彩斑斓的世界（色鸟鸟）\n7\n废萌\n\nFAVORITE\n\n\n40\n糖调！\n7\n废萌\n\nRecette\n\n\n41\n哥哥，早起前要一直抱紧我哦！+fd\n7\n拔作\n\nTinkle Position\n\n\n42\n与我恋爱的废柴恶魔\n7\n拔作\n\nSMILE\n\n\n43\n我的妹妹是碧池\n7\n拔作\n\nsofthouse-seal\n\n\n44\n双子洛丽塔后宫\n7\n拔作\n\n夜羊社\n\n\n45\n冥契的牧神节\n6\n剧情\n\nUGUISU KAGURA\n\n\n46\n魔女的夜宴\n7\n废萌\n\n柚子社 yuzu soft\n\n\n47\n将军大人芳华正茂\n6\n废萌\n\nALcot\n\n\n48\n妹锁\n6\n废萌\n\n-\n\n\n49\n母性萝莉近亲相奸\n6\n拔作\n\n-\n\n\n50\n龙姬 123\n6\n拔作\n\nWhirlpool\n\n\n51\n自闭妹妹的重生调教\n6\n拔作\n\n-\n\n\n52\n乱雪月华 12\n1\n拔作\n\nLass Lunatic\n\n\n","categories":["acg"],"tags":["galgame","表格","评分"]},{"title":"推荐阅读书目","url":"/2024/11/29/%E6%8E%A8%E8%8D%90/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/","content":"推荐阅读书目1. 数学\n《九章算术》\n\n作者：不详（汉朝）出版时间：公元前 1 世纪\n\n《几何原本》\n\n作者：欧几里得出版时间：约公元前 300 年\n\n《自然哲学的数学原理》\n\n作者：艾萨克·牛顿读书笔记链接：暂未上传\n\n《逻辑哲学论》 我们必须保持沉默\n\n作者：路德维希·维特根斯坦读书笔记链接：暂未上传\n\n《数学原理》\n\n作者：伯特兰·罗素\n\n《哲学研究》\n\n作者：路德维希·维特根斯坦\n\n《逻辑学的第二部分》\n\n作者：戈特洛布·弗雷格\n\n《思维规律研究》\n\n作者：乔治·布尔\n\n《逻辑的数学分析》\n\n作者：阿尔弗雷德·诺斯·怀特海\n\n《通信的数学理论》\n\n作者：克劳德·香农\n\n《数字情种——埃尔德什传》\n\n作者：阿尔弗雷德·E·霍夫曼\n\n《我的大脑敞开了》\n\n作者：保罗·爱多士\n\n《计算机与人脑》\n\n作者：阿尔文·图夫特\n2. 哲学\n\n《形而上学》（”Metaphysics”）\n亚里士多德（Aristotle）\n讨论存在、实体、因果关系等基本概念，奠定了西方形而上学的基础。\n\n\n\n纯粹理性批判》（”Critique of Pure Reason”）\n德（Immanuel Kant）\n讨知识的来源和界限，提出了先验知识和经验知识的区分。\n\n\n\n第二性》（”The Second Sex”）\n蒙娜·德·波伏娃（Simone de Beauvoir）\n析了女性在社会中的地位，探讨了性别与存在的关系。\n\n\n\n存在与时间》（”Being and Time”）\n丁·海德格尔（Martin Heidegger）\n究存在的本质，探讨人的存在及其在世界中的意义。\n\n\n\n哲学原理》（”Principia Philosophiae”）\n卡尔（René Descartes）\n出了怀疑主义的思考方法，强调思考的首要性。\n\n\n\n社会契约论》（”The Social Contract”）\n梭（Jean-Jacques Rousseau）\n讨政治权力的合法性与公民的权利，影响了现代政治哲学。\n\n\n\n道德形而上学基础》（”Groundwork of the Metaphysics of Morals”）\n德（Immanuel Kant）\n述了道德法则和义务伦理学的原则。\n\n\n\n正义论》（”A Theory of Justice”）\n翰·罗尔斯（John Rawls）\n出了公正的社会原则，探讨了公平与正义的社会结构。\n\n\n\n超越的权威》（”On Liberty”）\n翰·斯图尔特·密尔（John Stuart Mill）\n述了个人自由与社会权威之间的关系，强调了个人权利的重要性。\n\n\n\n《哲学的目的》（”The Purpose of Philosophy”）\n皮尔士（Charles Sanders Peirce）\n探讨了科学和哲学的关系，强调了实用主义的核心思想。\n\n\n\n《逻辑哲学论》（”Tractatus Logico-Philosophicus”）\n维特根斯坦（Ludwig Wittgenstein）\n提出了语言、世界和思维之间的关系，探讨了逻辑和语言的本质。\n\n\n\n《饕餮之宴》（Symposium）\n柏拉图式智性恋（Platonic Love 或 Platonic Friendship）\n\n\n\n3. 心理学\n《教养的迷思》读书笔记链接：暂未上传\n\n当代最伟大的思想家、世界顶尖语言学家和认知心理学家，史蒂芬·平克五部曲 by Steven Pinker\n\n\n\n《思想的本质》（The Stuff of Thought: Language as a Window into Human Nature ）：语言是洞察人类天性之窗\n《心智探奇》（How the Mind Works）：人类心智的起源与进化\n《语言本能》（The Language Instinct: How The Mind Creates Language）：人类语言进化的奥秘\n《白板》（The Blank Slate）：科学和常识所揭示的人性奥秘–人之初，性本善吗？\n《当下的启蒙》&#x2F;《启示录：我们为什么会进步》（Enlightenment Now）：为理性、科学、人文主义和进步辩护\n这是我最喜爱的一本书。 –比尔·盖茨\n\n\n\n4. 政治\n《共产党宣言》\n《我的奋斗》\n\n5. 编程语言\n《Types and Programming Languages (TAPL)》 by Benjamin C. Pierce简介：这是讨论类型系统和语言设计最经典的书之一，从类型论的角度深入剖析编程语言的基础。它不仅关注静态和动态类型系统，还包括类型推导、子类型、多态、递归类型等高级概念。\n\n适合读者：想探索编程语言设计背后数学逻辑基础、类型系统和表达能力的人。\n亮点：聚焦理论基础，探讨“类型作为语言设计核心”的哲学。\n\n《Concepts, Techniques, and Models of Computer Programming》 by Peter Van Roy, Seif Haridi简介：这本书从多种编程范式（如函数式、逻辑式、数据流式、并发式等）的角度，重新定义编程语言的基本构造与模型。它强调抽象模型，而非特定语言实现。\n\n适合读者：想从多范式视角理解语言设计的人。\n亮点：通过“语言与范式”统一理论，探索语言间的设计联系。\n\n《Programming Language Theory》 by John C. Reynolds简介：一本讨论编程语言设计理论的经典著作，探讨语法、语义以及编程语言设计中的高维度哲学问题。它提供了一种结构化方式去思考语言设计，而非只关注具体实现。\n\n适合读者：对编程语言设计背后的数学语义有浓厚兴趣的人。\n亮点：探讨语言的语义学，兼顾实用性与理论深度。\n\n《Design Concepts in Programming Languages》 by Franklyn Turbak, David Gifford, Mark Sheldon简介：这本书从设计哲学的角度出发，探讨编程语言的基本概念与构造，并结合实际例子分析语言特性如何影响程序行为。书中的概念贯穿许多现代语言。\n\n适合读者：想通过语言设计哲学，理解语言特性如何影响程序设计的人。\n亮点：以“设计选择”为核心，分析每种设计背后的理论和权衡。\n\n《The Science of Programming》 by David Gries简介：虽然这本书名义上是关于程序设计的科学，但实际上它更关注编程语言本身的逻辑基础和数学背景。书中从逻辑学出发，提出编程语言应该如何定义和推理。\n\n适合读者：对编程语言设计与逻辑有深入思考需求的人。\n亮点：将程序设计提升到形式化、科学化的高度。\n\n《Semantic Models for Programming Languages》 by Matthew Hennessy简介：深入探讨编程语言的语义模型，包括操作语义、代数语义和公理语义等，用抽象模型分析语言的行为。\n\n适合读者：想从抽象层面理解语言语义的理论家。\n亮点：强调语义的数学表达，关注编程语言设计的本质。\n\n《On the Design of Programming Languages》 by Peter J. Landin简介：由编程语言理论的早期先驱之一撰写，书中讨论了语言设计的哲学层面，包括“如何定义语言的核心构造”以及“语言特性如何映射到程序员的思维”。\n\n适合读者：对编程语言设计的哲学起源和发展有浓厚兴趣的人。\n亮点：探索早期编程语言设计中的哲学与动机。\n\n《The Art of Prolog》 by Leon Sterling, Ehud Shapiro简介：虽然这本书看似与 Prolog（逻辑编程语言）有关，但它更是一本关于如何以逻辑为核心重新设计编程语言的哲学讨论，适合理解不同编程范式背后的思想。\n\n适合读者：对逻辑式语言以及其哲学意义有兴趣的人。\n亮点：挖掘逻辑语言设计背后的高层次哲学和应用场景。\n\n《Formal Semantics of Programming Languages》 by Glynn Winskel简介：这本书专注于编程语言的形式语义学，重点讨论如何通过数学模型表达语言的构造、逻辑和行为。\n\n适合读者：对形式化方法和数学建模感兴趣的人。\n亮点：深入语义学的本质，提供严谨的形式化分析。\n\n《Essentials of Programming Languages (EOPL)》 by Daniel P. Friedman, Mitchell Wand, Christopher T. Haynes简介：这本书采用解释器驱动的方式讲解语言设计背后的核心理论，但它强调的不是实现，而是设计哲学，适合高层次思考语言的构造。\n\n适合读者：对语言特性和设计逻辑有深入兴趣的人。\n亮点：深刻剖析语言抽象与设计选择。\n","categories":["推荐"],"tags":["书籍","推荐"]},{"title":"营养饮食来源","url":"/2025/03/15/%E6%8E%A8%E8%8D%90/%E8%90%A5%E5%85%BB%E9%A5%AE%E9%A3%9F/","content":"1. 碳水化合物（Carbohydrates）主要能量来源，分为单糖、双糖、多糖。\n\n谷物类：大米、小麦、燕麦、玉米、小米、荞麦\n水果类：香蕉、苹果、葡萄、柑橘、梨\n蔬菜类：土豆、红薯、胡萝卜、南瓜、山药\n豆类：红豆、绿豆、鹰嘴豆、扁豆\n\n\n2. 蛋白质（Proteins）细胞修复、生长、免疫功能。\n\n肉类：牛肉、鸡肉、猪肉、羊肉、鱼肉\n蛋类：鸡蛋、鸭蛋、鹌鹑蛋\n奶制品：牛奶、羊奶、酸奶、奶酪\n豆类：黄豆、黑豆、扁豆、豌豆\n坚果种子：杏仁、核桃、花生、南瓜籽\n\n\n3. 脂肪（Fats）提供能量，支持细胞功能和激素合成。\n\n健康脂肪（不饱和脂肪）：\n\n植物油：橄榄油、菜籽油、亚麻籽油\n坚果种子：核桃、亚麻籽、奇亚籽\n鱼类（富含 Omega-3）：三文鱼、沙丁鱼、鲭鱼\n\n\n饱和脂肪（适量摄入）：\n\n肉类：牛肉、羊肉、猪肉\n奶制品：黄油、奶酪、全脂牛奶\n\n\n\n\n4. 维生素（Vitamins）促进新陈代谢，维持生理功能。\n\n维生素 A（视力、免疫）\n\n动物：肝脏、鱼肝油、蛋黄\n植物（β-胡萝卜素）：胡萝卜、红薯、南瓜、菠菜\n\n\n维生素 B 族（能量代谢、神经系统）\n\nB1：全谷物、豆类、猪肉\nB2：牛奶、鸡蛋、瘦肉\nB3：鸡肉、金枪鱼、蘑菇\nB6：香蕉、土豆、鸡胸肉\nB12（动物源）：牛肉、贝类、奶制品\n\n\n维生素 C（抗氧化，增强免疫）\n\n水果：柑橘、猕猴桃、草莓\n蔬菜：西红柿、青椒、卷心菜\n\n\n维生素 D（钙吸收，骨骼健康）\n\n动物：鱼肝油、三文鱼、鸡蛋\n强化食品：维 D 强化牛奶\n阳光：皮肤合成\n\n\n维生素 E（抗氧化）\n\n坚果：杏仁、葵花籽\n植物油：橄榄油、葵花籽油\n\n\n维生素 K（血液凝固）\n\n绿叶蔬菜：菠菜、羽衣甘蓝、西兰花\n\n\n\n\n5. 矿物质（Minerals）支持骨骼、神经、肌肉功能。\n\n钙（Ca）（骨骼、牙齿）\n\n奶制品：牛奶、酸奶、奶酪\n绿色蔬菜：羽衣甘蓝、西兰花\n坚果种子：芝麻、杏仁\n\n\n铁（Fe）（造血）\n\n血红素铁（易吸收）：红肉、动物肝脏、贝类\n非血红素铁（植物来源）：菠菜、豆类、黑芝麻\n\n\n镁（Mg）（神经、肌肉放松）\n\n坚果：腰果、杏仁\n全谷物：燕麦、糙米\n\n\n锌（Zn）（免疫、伤口愈合）\n\n肉类：牛肉、羊肉\n海鲜：牡蛎、螃蟹\n坚果：腰果、南瓜籽\n\n\n钾（K）（心脏健康）\n\n水果：香蕉、鳄梨\n蔬菜：菠菜、红薯\n\n\n\n\n6. 膳食纤维（Dietary Fiber）促进消化，调节血糖。\n\n可溶性纤维：\n\n水果：苹果、梨、柑橘\n豆类：红豆、鹰嘴豆\n\n\n不溶性纤维：\n\n全谷物：糙米、燕麦、小麦麸\n蔬菜：芹菜、胡萝卜、菠菜\n\n\n\n\n7. 抗氧化剂（Antioxidants）减少自由基损伤。\n\n类黄酮：蓝莓、黑巧克力、绿茶\n番茄红素：西红柿、西瓜\nβ-胡萝卜素：胡萝卜、南瓜\n花青素：葡萄、紫甘蓝\n\n\n8. 水（水 H₂O）必不可少，维持体温，促进新陈代谢。\n\n饮水：白开水、矿泉水\n含水食物：黄瓜、西瓜、橙子、番茄\n\n\n总结\n\n\n营养类型\n主要食物来源\n\n\n\n碳水化合物\n大米、土豆、香蕉、燕麦\n\n\n蛋白质\n牛肉、鸡蛋、豆类、奶酪\n\n\n脂肪\n橄榄油、鱼、坚果、黄油\n\n\n维生素 A\n胡萝卜、肝脏、红薯\n\n\n维生素 B 族\n猪肉、全谷物、鸡肉\n\n\n维生素 C\n柑橘、猕猴桃、青椒\n\n\n维生素 D\n三文鱼、蛋黄、牛奶\n\n\n维生素 E\n杏仁、葵花籽油\n\n\n维生素 K\n菠菜、西兰花\n\n\n钙\n牛奶、芝麻、绿叶蔬菜\n\n\n铁\n红肉、菠菜、黑芝麻\n\n\n镁\n燕麦、腰果\n\n\n锌\n牡蛎、南瓜籽\n\n\n钾\n香蕉、红薯\n\n\n膳食纤维\n燕麦、苹果、芹菜\n\n\n抗氧化剂\n蓝莓、西红柿、绿茶\n\n\n水\n白开水、水果\n\n\n","categories":["推荐"],"tags":["饮食","营养"]},{"title":"为什么说 IT 行业的“技术”是垃圾？","url":"/2024/12/30/%E8%AE%BA%E6%96%87/why-it-stupid/","content":"\n[!TIP]本文持续更新中…\n\n本文讲解就业问题，特别是互联网行业的“技术”相关问题。\n本文没有参考文献，因为我的思想是否为先人所发现过并不重要。\n\n\n\n冰冻三尺，非一日之寒。– 王充《论衡》–《状留篇》\n\n\n工欲善其事，必先利其器。– 《论语·卫灵公》\n\n\n通往罗马的路不止一条（all roads lead to Rome）– 《罗马典故》\n\n\n但我为什么指望我能影响自己的女儿呢？– 朱迪斯·里奇·哈里斯《教养的迷思》\n\n\n世界的意义存在于世界之外。世界是独立于我的意志的。幸运者的世界与不幸者的世界是不同的。– 路德维希·约瑟夫·约翰·维特根斯坦《逻辑哲学论》\n\n\n未经反思自省的人生没有意义。纵使富有的人以其财富自傲，但在他还不知道如何使用他的财富以前，别去夸赞他。– 苏格拉底\n\n\n没有反省的人生不值得活。人是寻求意义的动物。不知道自己的无知，乃是双倍的无知。智者说话，因为有话要说；愚者说话，因为要说些话。– 柏拉图\n\n\n整体大于部分之和。与战胜敌人的人相比，战胜欲望的人更加勇敢.他们活着，为了吃饭；而我吃饭，为了活着。– 亚里士多德\n\n\n每一个不曾起舞的日子，都是对生命的辜负。自由的保证是什么？是对自己不再感到羞耻。人们杀死了上帝，却又崇拜一个个偶像。一棵树要长得更高，接受更多的光明，那么它的根就必须更深入黑暗——深入恶中。– 弗里德里希·威廉·尼采\n\n\n我们必须设想西西弗斯是幸福的。 – 阿尔贝·加缪\n\n\n鱼与熊掌不可得兼。 – 孟子\n\n\n实践是检验真理的唯一标准。 – 邓小平\n\n\n活着这个词在中国的语境里充满了力量，它的力量不是来自于呐喊，也不是来自于反抗，而是要忍受，去忍受现实中的苦难和平庸，去忍受生命中本不该有的不公与不义。在这样的世界里，有一种心眼坏了，叫知足常乐;有一种眼睛瞎了，叫岁月静好;有一种耳朵聋了，叫与世无争。中国是这三种人的天堂。– 余华\n\n万种不堪无所谓，苟活世间品百味。\n\n\n\n最忌讳：\n\n贪图享乐，又好吃懒做。\n无财无能，又贪财好色。\n眼高手低，又怨天尤人。\n无勇无谋，又勤于谋策。\n\n间歇性踌躇满志，持续性混吃等死\n\n\n简单问题复杂化，复杂问题虚无化，是大部分人解决问题的办法。\n\n\n我站在巨人的肩膀上，我爬上同伴们的尸体，我才来到这样的一个高度，我必须有我的担当。\n\n\n不要努力，努力毫无意义，努力唯一的作用就是自我感动。不要加油。要保持健康的节奏，遵循事物发展的规律，然后执行而不是努力。\n\n\n劳动人民的双手创造真正的价值，而不是抽象的简历、IT 黑话、符号、股票。\n\n\n技能，语言，实践，眼光。\n\n为什么说 IT 行业的“技术”是垃圾？摘要本文讲解就业问题，特别是互联网行业的“技术”相关问题。\n本文没有参考文献，因为我的思想是否为先人所发现过并不重要。\n关键词：就业 互联网 IT 编程 技术 资本\n一、背景目前，IT 行业蓬勃发展，各种技术层出不穷。特别是在人工智能领域，热点研究就是大语言模型。\n在全世界都在大力发展 AI 时，中国互联网行业却呈现出不一样的姿态。根据 Jetbrains 的调查，中国有 50%以上的程序员是 java 程序员。这与电商时期中国互联网行业的飞速发展有关。以阿里巴巴、字节跳动、腾讯、美团等为首的互联网头部企业，垄断了 IT 技术能够垄断的一切服务业——财务、娱乐、游戏、衣食住行等。\n由于中国的网络长城防火墙保护主义，国外的垄断企业（Youtube、telegram、X、Google 等）不会压制到国内企业发展。因此，国内互联网行业别有一番风景。\n在 2023 年互联网“寒冬”时期后，已经成体系的 Java 培训、Java 就业、Java 升职系统彻底崩盘。此前十年间，大部分本科学生只要会一点点 408 和后端知识，就可以轻松拿到大厂 offer，斩获几十万年薪。但在疫情的影响下，泡沫经济时代的代表行业——互联网行业，开始呈现颓势。\n为什么，会变成这样呢？\n二、问题提出2.1. “技术”到底是什么？为什么有技术？为什么说技术都是垃圾？如何学到真技术？2.2. 资本主义垄断企业的本质是什么？为什么要反对资本主义？如何杀死资本主义？2.3. 就业问题的根源是什么？如何解决？三、问题解答3.1. 技术3.1.1. 技术源自需求——先有需求，才有技术3.1.2. 技术为什么流行？3.1.3. 技术为什么容易上手？3.1.4. 技术为什么垃圾？3.1.5. 什么是真正的技术？3.2. 企业与资本3.2.1. 企业的根本属性——资本性3.2.2. 垄断的恶果3.2.3. 技术越强，越找不到工作3.3. 就业3.3.1. 落后的思想——愚昧的大学生3.3.2. 就业的本质——资本的调控3.4. 睁眼看世界3.5. 我们的局限性杂谈积屎成山，技术兴焉我说了，流行的都是垃圾越快就越垃圾就像豆包，Kimi，百度等等垃圾都想着拿新技术捞钱捞得到，就成了主流捞不到就被废弃资本家只会投资现在的计算机架构，是最垃圾的一种架构所有的技术，都是，谁先诞生，谁就成了主流c 语言 c 加加一坨屎但没办法，你不能花大量时间重写rust 很好，但你不能用爱发电你打不破资本这叫“技术垄断”抢占了技术市场，就会成为技术权威，垄断技术领域，从而抑制新思想新技术因此，目前的所有技术，本质上都是垃圾是最垃圾的所有世界线里面最垃圾的因为前辈想的是：“能跑就行”现在人想的是“代码和我有一个能跑就行”资本家想的是“怎么快速捞钱”根本没几个人在乎技术Python 之父在乎，有用吗？Python 基金会早就变成技术垄断主义，权威崇拜主义，互联网封建主义，小资产阶级精英主义的天下了你 py 之父都没用现在的 py 一坨屎有个成功学家（资本家，企业家）的那本书，讲了“最先”和“最优”的关系“最先”一定能笑到最后“最优”则是暂时的必须每个发展阶段都是“最优”才能最优很难懂对吧？意思就是抢占和垄断说的很高大上就是，如果你一直是第一名，你才被称为学霸你偶尔第一名，那就运气他也讲了“第二名等于最后一名”只有第一名才有意义意思就是“绝对的垄断”资本如此，技术也一样c 语言就是那个垄断语言不管什么技术都绕不开 c那 c 好吗？并不好为什么垄断？因为他最早被造出来最早，那一定是最差的但是，越早就越可能垄断市场因此，我说，现在的技术，都是最垃圾的没有之一人类社会的世界线，永远朝着最差的方向发展这是必然的积屎成山，技术兴焉通往罗马的路不止一条，但如果第一条路被开辟出来，大家就会一股脑涌上去你说“水路可能更快更好更能载人更省钱”但“人们早就不在乎了”等你水路开完，人们早就形成了“两点之间，线段最短的土路刻板印象的权威主义”所以 rust 必然打不过 c今天这段话，我以为我早就潜移默化说过无数遍了，但有时候，不说清楚就是不能准确表情达意所以我还是整理一下通俗点讲出来比较好写进那篇文章里面“为什么说 it 行业技术都是垃圾”英文名叫“why-it-stupid”这名字也很有意思噢IT 和 it其实，非 IT 领域也一样所以我不用大写人类社会永远朝着最差的技术路线发展人们总是做时间紧但价值低的事比如写作业比如上课听讲比如考试考证而不看书不读书不学课外知识不健身不保养，只化妆买电产，不保修买车不养车做饭不养锅冰冻三尺，非一日之寒积土成山，风雨兴焉积水成渊，蛟龙生焉积善成德，而神明自得，圣心备焉姑不积跬步无以至千里不积小流无以成江海人们总是只看到眼前的蝇头小利而不会以发展的眼光看世界\n\n扩展延伸阅读\nhttps://m.huxiu.com/article/3334240.html\n对话 RWKV 作者[彭博]：单枪匹马挑战 Transformer 的神秘怪才\n\n\nhttps://m.huxiu.com/article/3827317.html\n软件行业有很多“潜规则”，行外人不知道，行内人不能说。因为说出来会被视为“行业叛徒”——比如我\n\n\nhttps://bbs.kanxue.com/thread-282784.htm\n（网吧传奇霸业的计算机安全攻防技术与利益）无硬盘、网络拦截、进\\线程、（有&#x2F;无）模块注入、文件、注册表、窗口拦截、驱动注入、浏览器抢占、登陆器封禁、替换软件渠道号、hook 与 unhook、拦截与反拦截、注入与反注入。\n\n\nhttps://cloud.tencent.com/developer/article/2148368\n没有二十年功力，写不出这一行“看似无用”的代码！\nThread.sleep(0);\n\n// src: org.apache.rocketmq.store.logfile.DefaultMappedFile#warmMappedFilefor (int i = 0, j = 0; i &lt; this.fileSize; i += DefaultMappedFile.0S_PAGE_SIZE, j++) &#123;    // ... 业务代码 ...    // prevent gc    if (j % 1000 == 0) &#123;        try &#123;            Thread.sleep(0);        &#125; catch (InterruptedException e) &#123;&#125;    &#125;&#125;\n\n\nhttps://github.com/apache/rocketmq/blob/develop/store/src/main/java/org/apache/rocketmq/store/logfile/DefaultMappedFile.java\nhttps://github.com/apache/rocketmq/pull/4903\nhttps://github.com/apache/rocketmq/commit/613d483a18bddcea26783d1e80752360821afce9\n\n\n\n\nhttps://cloud.tencent.com/developer/article/1493036\n逐帧分析：YouTube 使用了什么独门技术？（高性能、高可用、容错、缓存、懒加载、预渲染、http3&#x2F;quic 协议、流媒体协议、压缩、内联、内嵌 svg、资源重用、编码格式）\n\n\nhttps://blog.sina.com.cn/s/blog_4b0e23c90100b2qf.html\n《我的程序人生路》– 雷军1996 年 5 月写于金山西点 BBS【题记】 如果程序人生的话，这条路太漫长\n\n\nhttps://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter02/LSMTree.html\nLSM 树，即日志结构合并树(Log-Structured Merge-Tree)。其实它并不属于一个具体的数据结构，它更多是一种数据结构的设计思想。大多 NoSQL 数据库核心思想都是基于 LSM 来做的， 只是具体的实现不同。\n\n这是一本 java 程序员写的必备知识积累之书。可以说是一本进击之书。命名为《进击的 java 菜鸟》。\n\n\n\n\n","categories":["杂谈"],"tags":["杂谈","就业","IT","互联网","编程","技术","资本"]},{"title":"读书笔记-《教养的迷思》","url":"/2025/01/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%95%99%E5%85%BB%E7%9A%84%E8%BF%B7%E6%80%9D%E3%80%8B/","content":"读书笔记-《教养的迷思》\n[!TIP]未特殊说明的，均为笔记内容，并非原文。\n\n《教养的迷思》[美] 朱迪思·里奇·哈里斯 著\n张庆宗 译\n\n书名：教养的迷思 父母的教养方式能否决定孩子的人格发展？\n作者：【美】朱迪斯·哈里斯\n出版社：上海译文出版社\n出版时间：2016 年 4 月\nISBN：9787532769902\n本书由上海译文出版社授权得到 APP 电子版制作与发行\n版权所有·侵权必究\n\n读书笔记-教养的迷思-朱迪思·里奇·哈里斯\n序言\n第一版序言：\n《教养的迷思》是一部严肃的、具有原创性的科学著作。我预测该书将是心理学史上的一个转折点。\n斯蒂芬·平克https://zh.wikipedia.org/wiki/%E6%96%AF%E8%92%82%E8%8A%AC%C2%B7%E5%B9%B3%E5%85%8B\n马萨诸塞州剑桥市1998 年 5 月\n\n孩子从父母那得到的只有基因和物质基础，还有暴力压迫（程度的大小不同）。\n朱迪思说，她女儿甚至不听她的最新理论，仍在用老旧的费力费时的副作用的教育方式，来教育她女儿的孩子，但她又怎么能要求女儿能够受她的影响呢？她很佛系。毕竟她的理论便是：儿女人格与父母教养没有任何关系，教养理论与研究都是毫无价值的。\n\n原文：“专家们”是错误的。父母的教养并不能决定孩子的成长，孩子的社会化不是家长帮助完成的。教养假设是一个无稽之谈，许多支持教养假设的研究都毫无价值\n\n前言诗歌你的儿女，其实不是你的儿女。他们是生命对于自身渴望而诞生的孩子。他们借助你来到这世界，却非因你而来。他们在你身旁，却并不属于你。你可以给予他们的是你的爱，却不是你的想法，因为他们有自己的思想。你可以庇护的是他们的身体，却不是他们的灵魂，因为他们的灵魂属于明天，属于你做梦也无法到达的明天。你可以拼尽全力，变得像他们一样，却不要让他们变得和你一样。因为生命不会后退，也不在过去停留。——卡里·纪伯伦\n\n第一章 “教养”不同于“环境”基因与教养，现在叫“先天与后天”（这本书我还没读过），这些词听起来太牛逼了，很高大上，那么如何揭开“教养的迷思”？请听朱迪思分解。\n这本书并不是基因决定论这种无聊的书，也并没有完全否定后天环境的影响，而是关于“教养”的迷思，有反直觉的最新的无法被证伪的一些看法，最初受到批判，而最后，开创新时代。\n“教养，狭义指家庭或学校的教育性实施，对个人身心发展所产生的综合影响。广义指后天环境中影响个体身心发展的所有因素之总和。在本书中，nurture 视行文译为教养或后天，其意为专指父母为子女所做的一切。——译者。”\n“人们说，天才是九十九分努力，加一分灵感。而行为主义只关注努力，却忘掉了灵感”其实是这样的，这句话并不是说，努力就能成功，也不是说努力更加重要，而是在说：只要你有一点灵感，你就可以努力至成功；如果你没有灵感，那么你努力到百分之二百也没用。\n第二章 先天禀赋（和后天教养）的证据“一个长相丑陋的婴儿是一个非常令人讨厌的东西。” ——维多利亚女王\n在大量的双生子研究中，下列研究都得到了有效数据：\n\n同卵双胞胎，在同一个家庭长大。\n同卵双胞胎，在不同家庭长大。\n异卵双胞胎，在同一个家庭长大。\n异卵双胞胎，在不同家庭长大。\n\n事实证明：相似性顺序 1&#x3D;2&gt;3&#x3D;4。\n意思是：家庭完全不会影响孩子人格发展，孩子人格的一部分由基因决定，另一部分由不是家庭环境的其他环境所影响。因为，同一个家庭可能有完全不同的环境，这是“基因效应的效应”\n原文：\n\n“家长更喜欢看长得可爱的婴儿，更愿意与他们一起玩耍。在该研究中，研究者引用了维多利亚女王写给自己已出嫁女儿的一句话。女王自认为对婴儿很在行（她一共生了九个孩子），她说：“一个长相丑陋的婴儿是一个非常令人讨厌的东西。”\n大多数长得丑的婴儿长大以后会变得好看一些，但想想那些长相没变的孩子。人们对相貌平庸的孩子的态度远不如对漂亮孩子那么友善。当相貌平庸的孩子做错了事，他们会受到严厉的惩罚；即使他们没有做错什么，人们也会迅速地认定是他们做错了。长相平庸和长得漂亮的孩子生活体验不同，成长环境不同。”\n\n我的理解:\n并非好环境造就了好孩子，而是好孩子造就了好环境。天生聪明漂亮的孩子一定比天生丑陋愚笨的孩子受到更多的赞美鼓励爱护，淘气的孩子一定比文静的孩子挨打多。并非父母对孩子的冷漠导致孩子自闭自卑，而是孩子自闭自卑导致了父母的冷漠对待。\n世界上不存在因果论，因果论是谬论。我调查了很多死亡的人，发现它们生前都喝过水。因此我得出结论：喝水导致死亡。实际上，不喝水才会导致死亡。但是，我从哪里寻找不喝水的人呢？\n我从哪里寻找一个天生没有任何 DNA，不聪明也不愚笨，不漂亮也不丑陋，不淘气也不文静，不善良也不邪恶，不男不女，不高不矮，不胖不瘦，不像人类也不像非人类，不会说话也不会闭嘴，不会思考也不会呆滞，不会吃饭也不会饿着，不会睡觉也不会醒着，不会躺着也不会走着，对父母的任何行为既有反应又没有反应，跟别的孩子既不相同也没有差异，并且不管孩子做什么或不做什么，父母对孩子都只会赞美而不是谩骂，或者只会谩骂而不是赞美，周围所有人、社会、机构、动物也都对孩子表现出同样的表现，不管孩子是真善美还是假恶丑，不管孩子做了好事还是犯了罪，不管孩子是不是人，不管孩子是不是孩子，不管任何利益、时空因素、时代因素、经济政治文化因素，这个“孩子”的环境都跟孩子本身没有任何关系。如何找到这样的孩子？\n真的存在因果关系吗？力的作用不是相互的吗？你能说是我给了你一个力，而你没有给我一个大小相等，方向相反的力吗？\n可爱的孩子不应该得到更多夸赞吗？犯罪的孩子不应该得到惩罚吗？是惩罚导致了犯罪？还是犯罪导致了惩罚？\n你的孩子，其实不是你的孩子。你的孩子，是宇宙的孩子。他们借由你们之身，降临这个世界。他们来自你，却不属于你。\n“一个长相丑陋的婴儿是一个非常令人讨厌的东西。”。\n并非父母的讨厌导致孩子长得丑，而是孩子长得丑导致父母讨厌。千万不要因果倒置，本末倒置。\n不过，因果和本末，真的存在吗？\n第三章 先天禀赋，后天教养，抑或两者都不是为了维护心理学权威谣言“父母对孩子有影响”，就必须要找到这影响，哪怕没有影响，也要硬扯一个。\n原文：“鉴于社会化研究中相关性不强、趋势较弱，加上行为遗传学出现的令人不安的研究结果，麦科比和马丁得出以下结论：\n“这些发现强有力地说明，父母给孩子提供的物质环境对孩子的影响很小。父母的基本特质，如父母的受教育程度、夫妻关系的好坏等，对孩子的影响也很小。研究结果表明，要么父母的行为对孩子没有影响，要么父母的行为对不同的孩子有不同的影响。”\n父母有没有工作，读不读书，酗不酗酒，打不打架，结婚还是离婚，这些我们以为对孩子来说一定是很重要的事情，结果发现它们对孩子没有什么影响。同样，一个家庭的物质环境，例如是公寓还是农庄，宽敞还是拥挤，凌乱肮脏还是干净整洁，家中放着艺术品、厨房放着豆腐，还是家中堆满汽车零件、厨房放满零食，这些对孩子来说一定是很重要的事，结果发现也对孩子没有产生什么影响。\n我们陷入了因果关系的无限循环中。我们怎么知道妈妈不是因为你本来就比较聪明才偏爱你呢？你是因为聪明才被父母称为“天才”，还是因为被称为“天才”才变得聪明的？如果父母对待每个孩子的方式不同，是他们对孩子之间差异的回应，还是他们引发了这些差异呢？”\n1，出生顺序\n原文：“但是对出生顺序的信念并没有轻易地消失，它是那种多次被打倒，但又立刻爬起来的东西。在许多重振出生顺序信念的努力中，最引人注目的是科学史家弗兰克·萨洛韦（Frank Sulloway）。在《生而叛逆》（Born to Rebel）一书中，萨洛韦声称，凡是科学、宗教和政治思想的革新都是老大率先反对，后出生的孩子支持，因为后出生的孩子有一种“开放的心态”。然而，我注意到革新的思想并不一定来自老二、老三甚至老四：伽利略、牛顿、爱因斯坦、马丁·路德·金、弗洛伊德和毛泽东都是老大。”\n很容易想到，出生顺序导致老大和老二被不同的对待了，那么这种对待的差异性，算不算环境差异呢？答案是否定的，即：出生顺序对孩子人格发展没有任何影响。\n2，父母的教养方式","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"not, but","url":"/2024/11/25/%E8%AF%97%E6%AD%8C/not-but/","content":"持续更新中…\nnot, butnot same, but somorphism.not implementation, but interface.not instance, but class.not variable, but struct.not semblance, but manifestation.不是表象，而是表现semblancerepresentationperformanceappearencephenomenonshow\n\n\nTractatus Logico-philosophicus by [Ludwig Josef Johann Wittgenstein]\n\n\nnot reasonable, but occur.\n\nnot thing, but fact.\n\n\nnot whole, but part.\n\nnot molecule, but atom.\nnot accidental, but inherent.\nnot extrinsic, but intrinsic.\nnot imagine, but common.\nnot property, but form.\nnot object, but configuration.\nnot substance, but structure.\nnot causal, but Independent.\nnot graph, but display.\n\n\nnot thought, but image.\n\nnot self, but other.\nnot words, but proposition.\nnot tones, but melody.\nnot design, but describe.\nnot point, but arrow.\nnot what, but how.\nnot one, but only one.\nnot define, but initial.\nnot variable, but regulation.\nnot symbol, but notation.\nnot nature, but logic.\nnot notation, but form.\nnot special, but common.\nnot combination, but designation.\n\n\nnot true or false, but meaningless.\n\nnot philosophy, but natural science.\n\nnot doubt, but negate.\n\nnot believe, but prove.\n\nnot prove, but assert.\n\nnot describe, but keep silent.\n\n\n\nThe Zen of Python, by Tim Peters\n\nnot true or false, but good and bad.\n\nnot lucky, but happy.\n\nnot say, but do.\n\nnot later, but now.\n\nnot right now, but mull.\n\nnot code, but demand.\n\nnot repeat, but once.\n\nnot strict, but compat.\n\nNot ugliness, but beauty.\n\nnot implicit, but explicit.\n\nnot complex, but simple.\n\nnot complicated, but complex.\n\nnot nest, but flat.\n\nnot dense, but sparse.\n\nnot performance, but readability.\n\nnot purity, but practicality.\n\nnot second, but first.\n\nnot one, but more.\n\nnot more, but best.\n\nnot best, but better.\n\nnot help, but self.\n\nnot teach, but learn.\n\nnot copy, but imitation.\n\n\n\nExplicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than _right_ now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!\n","categories":["诗歌"],"tags":["诗歌","哲学","思想碎片"]},{"title":"孩子，你好。幸福的活下去 -《教养的迷思》读后诗歌","url":"/2024/11/23/%E8%AF%97%E6%AD%8C/%E5%AD%A9%E5%AD%90%EF%BC%8C%E4%BD%A0%E5%A5%BD%E3%80%82%E5%B9%B8%E7%A6%8F%E7%9A%84%E6%B4%BB%E4%B8%8B%E5%8E%BB%20-%E3%80%8A%E6%95%99%E5%85%BB%E7%9A%84%E8%BF%B7%E6%80%9D%E3%80%8B%E8%AF%BB%E5%90%8E%E8%AF%97%E6%AD%8C/","content":"孩子，你好。幸福的活下去——《教养的迷思》读后诗歌\n所以，我今天要写一点心灵鸡汤，为我，也为你。\n孩子，你好你的想法没有任何错误你的聪明活泼天地可鉴你的大脑比天空更加辽阔你的思维比海洋更加深沉你的父母压迫你不用害怕，厚积薄发氤霭只是暂时的相信吧，快乐之日将会来临！你的同类排斥你不用害怕，保持冷静天之骄子岂会与区区小人计较？走自己的路，让他们说去吧！孩子，你好如果你相信，真理掌握在多数人手里那你便是那多数人如果你发现他们跟你思想不同那只是他们暂时没有醒悟而已请坚信，真理一定在多数人手中如果你相信，真理掌握在少数人手里那你便是那少数人请坚信你自己的真理，不要管他人之言语因为人没有信仰，是无法生存的孩子，你好你是天地之精你是自然之美你是大自然的生命你是全宇宙的孩子你的父母，其实不是你的父母，他们只负责带你来到这个世界你可以全力活出自己的精彩而不要让任何老年人评价你因为生命不会后退，也不在过去停留。天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。孩子，你好如果你有轻生的想法，请不妨先听我讲活着对你而言本来就没有意义但这并不影响你活着世界的意义在于世界之外你的意义在于服务其他人其他人的意义在于服务你不要害怕，不要逃避死亡解决不了任何问题逃避只会带来更多痛苦所以，孩子啊，幸福的生活下去吧！从此以后，不要对未来抱有希望不要沉溺于幸运而高兴不要对未来感到绝望不要堕落于不幸而绝望只要，幸福的，活下去——\n\n前言诗歌\n你的儿女，其实不是你的儿女。\n他们是生命对于自身渴望而诞生的孩子。\n他们借助你来到这世界，却非因你而来。\n他们在你身旁，却并不属于你。\n你可以给予他们的是你的爱，却不是你的想法，\n因为他们有自己的思想。\n你可以庇护的是他们的身体，却不是他们的灵魂，\n因为他们的灵魂属于明天，属于你做梦也无法到达的明天。\n你可以拼尽全力，变得像他们一样，\n却不要让他们变得和你一样。\n因为生命不会后退，也不在过去停留。\n——卡里·纪伯伦\n\n","categories":["诗歌"],"tags":["读书笔记","诗歌","心灵鸡汤"]},{"title":"读书笔记-《罗素论自由》","url":"/2025/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%BD%97%E7%B4%A0%E8%AE%BA%E8%87%AA%E7%94%B1%E3%80%8B/","content":"\n[!TIP]未特殊说明的，均为笔记内容，并非原文原意。\n\n读书笔记-《罗素论自由》第一章：马克思和社会主义学说。议会制与无政府主义和工团主义的矛盾，关键在于议会制的代表人选取方式本身是不民主的，三者都追求民主和社会公有制。\n马克思吸收了黑格尔的思想，抛弃了黑格尔那些确定的结论（这几乎是所有创新者的通病）。\n马克思学说最基本的内容被罗素归纳为：\n\n历史唯物主义（经济决定道德和观念）\n资本集中规律（垄断会导致资本阶级降级为无产阶级）\n阶级斗争（偏向革命而不是进化）\n\n狂热的共产主义者！诗歌，口号，共产党宣言，而不是纯哲学，善良的但也是激进的。\n剩余价值学说，毋宁看做用抽象的语言对资本吃人制度的控诉，崇拜者们也是狂热愤怒的而不是冷静分析的。\n","categories":["读书笔记"],"tags":["读书笔记"]},{"title":"学习FastAPI","url":"/2023/10/23/%E5%AD%A6%E4%B9%A0/%E6%80%BB%E7%BB%93/learn-fast-api/","content":"Fast API 学习使用 FastAPI 构建数据管理系统时，保持代码科学和优雅的关键在于模块化、依赖注入、良好的异步支持，以及清晰的结构设计。以下是基于 FastAPI 的最佳实践，以及如何科学优雅地编写你提到的系统的建议：\n1. 项目结构设计保持项目结构的清晰和模块化是优雅开发的基础。以下是推荐的目录结构：\nproject/├── app/│   ├── api/                   # API 路由和视图│   │   ├── v1/│   │   │   ├── tasks.py       # 处理数据任务管理的路由│   │   │   ├── templates.py   # 处理清洗模板管理的路由│   │   │   └── clean.py       # 处理数据清洗相关的路由│   ├── core/│   │   ├── config.py          # 配置文件，数据库、日志、Celery配置等│   │   ├── dependencies.py    # 依赖项，如数据库会话、队列等│   │   └── celery.py          # Celery 配置及任务管理│   ├── models/                # 数据库模型（Pydantic 和 SQLAlchemy）│   │   └── task.py            # 任务模型│   ├── services/              # 业务逻辑│   │   ├── download.py        # 数据下载服务│   │   ├── clean.py           # 数据清洗服务│   │   └── templates.py       # 清洗模板服务│   ├── db.py                  # 数据库连接和管理│   ├── main.py                # FastAPI 入口│   ├── tasks/                 # Celery任务│   │   └── tasks.py│   └── utils/                 # 工具函数、帮助类├── tests/                     # 单元测试与集成测试├── requirements.txt           # 依赖文件├── docker-compose.yml         # Docker 配置（可选）└── README.md                  # 项目说明\n\n\n2. 使用依赖注入管理依赖FastAPI 的依赖注入系统是简洁优雅代码的重要组成部分。通过依赖注入，你可以确保每个函数、路由、类只使用必要的依赖项，而不引入不必要的耦合。\n# app/core/dependencies.pyfrom sqlalchemy.orm import Sessionfrom app.db import SessionLocal# 数据库会话依赖注入def get_db():db = SessionLocal()try:yield dbfinally:db.close()# 其他依赖，比如缓存、任务队列等，也可以通过类似方式注入\n\n在 API 中使用这些依赖：\n# app/api/v1/tasks.pyfrom fastapi import APIRouter, Depends, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom app.core.dependencies import get_dbfrom app.services import task_servicerouter = APIRouter()@router.post(&quot;/tasks/&quot;)async def create_task(data_source: str, db: Session = Depends(get_db)):task = task_service.create_task(db, data_source)if not task:raise HTTPException(status_code=400, detail=&quot;Task creation failed&quot;)return task\n\n\n3. 异步编程FastAPI 原生支持异步，利用它可以提高系统在高并发场景下的性能。任务如数据下载、清洗等耗时操作，可以使用异步任务队列，如 Celery 或直接使用 async 函数。\n# app/api/v1/clean.pyfrom fastapi import APIRouter, Depends, BackgroundTasksfrom app.services.clean import clean_sample_datarouter = APIRouter()@router.post(&quot;/clean/&quot;)async def clean_data(dataset_id: int, background_tasks: BackgroundTasks):background_tasks.add_task(clean_sample_data, dataset_id)return &#123;&quot;message&quot;: &quot;Sample cleaning started&quot;&#125;```python# app/services/clean.pyasync def clean_sample_data(dataset_id: int): # 模拟异步清洗await asyncio.sleep(5)print(f&quot;Cleaning complete for dataset &#123;dataset_id&#125;&quot;)\n\n\n4. 使用 Pydantic 进行数据验证和序列化Pydantic 是 FastAPI 的核心，可以帮助你定义并验证输入、输出数据结构。优雅的设计离不开清晰的模型定义。\n# app/models/task.pyfrom pydantic import BaseModelfrom typing import Optionalclass TaskCreate(BaseModel):data_source: strbranch: Optional[str] = &quot;main&quot;class TaskResponse(BaseModel):id: intdata_source: strstatus: str\n\n# app/api/v1/tasks.pyfrom app.models.task import TaskCreate, TaskResponse@router.post(&quot;/tasks/&quot;, response_model=TaskResponse)async def create_task(task: TaskCreate, db: Session = Depends(get_db)):new_task = task_service.create_task(db, task)return new_task\n\n这种方式能够确保 API 的输入和输出都经过严格的验证，减少错误发生的可能性。\n\n5. 数据库与 ORM使用 SQLAlchemy（或者 Tortoise ORM）来管理数据库事务，同时通过 Pydantic 进行数据校验。对于大规模的并发请求，使用异步数据库连接（如 asyncpg）。\n# app/db.pyfrom sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmakerSQLALCHEMY_DATABASE_URL = &quot;mysql://user:password@192.168.31.121/dbname&quot;engine = create_engine(SQLALCHEMY_DATABASE_URL)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# app/models/task.pyfrom sqlalchemy import Column, Integer, Stringfrom app.db import Baseclass Task(Base):**tablename** = &quot;tasks&quot;    id = Column(Integer, primary_key=True, index=True)    data_source = Column(String, index=True)    status = Column(String, default=&quot;pending&quot;)\n\n\n6. 任务队列（Celery 集成）长时间运行的任务（如数据下载、清洗）应放入后台队列中。Celery 是一个成熟的任务队列，可以与 FastAPI 无缝集成。\n# app/core/celery.pyfrom celery import Celerycelery_app = Celery(&quot;worker&quot;,broker=&quot;redis://localhost:6379/0&quot;,backend=&quot;redis://localhost:6379/0&quot;)# 启动任务@celery_app.taskdef download_data_task(data_source: str): # 模拟下载任务import timetime.sleep(10)return f&quot;Data from &#123;data_source&#125; downloaded&quot;\n\n# app/api/v1/tasks.pyfrom app.core.celery import download_data_task@router.post(&quot;/tasks/&#123;task_id&#125;/download&quot;)async def download_task(task_id: int):download_data_task.delay(task_id)return &#123;&quot;message&quot;: &quot;Download task started&quot;&#125;\n\n\n7. 测试与文档FastAPI 自动生成 API 文档，使用 OpenAPI。只需要运行应用程序，访问 /docs 即可查看。编写单元测试和集成测试，确保每个模块都能独立测试。使用 FastAPI 提供的 TestClient 进行 API 测试：\n# tests/test_tasks.pyfrom fastapi.testclient import TestClientfrom app.main import appclient = TestClient(app)def test_create_task():response = client.post(&quot;/tasks/&quot;, json=&#123;&quot;data_source&quot;: &quot;huggingface&quot;&#125;)assert response.status_code == 200assert response.json()[&quot;data_source&quot;] == &quot;huggingface&quot;\n\n\n8. 日志与错误处理良好的日志和错误处理能够帮助你快速定位问题，确保系统的健壮性。使用 Python 的 logging 模块并集成到 FastAPI 中。\n# app/core/logging.pyimport logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(**name**)# 在业务代码中logger.info(f&quot;Task &#123;task_id&#125; started downloading&quot;)\n\n# app/api/error_handlers.pyfrom fastapi import HTTPException, Requestfrom fastapi.responses import JSONResponseasync def http_exception_handler(request: Request, exc: HTTPException):return JSONResponse(status_code=exc.status_code,content=&#123;&quot;detail&quot;: exc.detail&#125;)\n\n\n9. Docker 化项目使用 Docker 打包项目，确保项目在各种环境中一致运行：\n# DockerfileFROM python:3.9-slimWORKDIR /appCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtCOPY . .CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]\n\n使用 docker-compose.yml 管理多服务的启动（如 FastAPI、Celery、Redis）。\n","categories":["学习"],"tags":["学习","python","FastAPI"]},{"title":"css - color - 调色板 - 水色 - 粉红色","url":"/2024/11/30/%E5%AD%A6%E4%B9%A0/%E6%A1%88%E4%BE%8B/color/","content":"css - color - 调色板 - 水色 - 粉红色\n","categories":["前端"],"tags":["前端","css","颜色"]},{"title":"离散数学-抽象代数复习笔记","url":"/2024/10/31/%E5%AD%A6%E4%B9%A0/%E6%80%BB%E7%BB%93/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/","content":"本文为离散数学-抽象代数复习笔记，只给结论不给证明。\n一、抽象代数-概述https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0\n1. 二元运算（S, *）：\n定义：满足封闭性\n\n原群：\n定义：只满足封闭性\n\n半群：\n定义：满足结合律的原群\n\n循环半群（可生成半群）\n定义：一个半群是可生成的，如果存在一个元素 g 使得任何其他元素都可以由 g 通过半群运算获得。\n\n幺半群（独异点）：\n定义：有单位元的半群\n\n群：\n定义：有逆元的独异点\n\n\n拉格朗日定理:对于任何有限群 G, 子群 H 的阶（元素个数）整除 G 的阶。\n\n\n拉格朗日定理的一个推论:如果群 G 的阶是一个质数，那么\n\nG 是循环群，\nG 仅有两个子群—平凡子群（仅含单位元）和 整个群 𝐺\n\n\n重要性：这个定理限制了子群大小，并在求解群的结构时非常有用。\n\n秀尔算法（把整数分解转化为阶的搜索）。https://zh.wikipedia.org/wiki/%E7%A7%80%E7%88%BE%E6%BC%94%E7%AE%97%E6%B3%95#%E5%82%B3%E7%B5%B1%E9%83%A8%E4%BB%BD\n找出 a 在 ZN (整数模 N 同余群) 里面的阶 r。\n备注: ZN 的阶是 N，而 a 在 ZN 中的阶 r 就是 Za 的阶 r，因此根据拉格朗日定理 r mod N &#x3D; 0。\n\n交换群（阿贝尔群）：\n定义：满足交换律的群\n\n\n阿贝尔群的子群是阿贝尔群\n\n循环群（可生成群）：\n定义：每个元素都可表示为 g 的 n 次幂。g 称为生成元\n\n\n每个循环群都是阿贝尔群。\n\n同构基本定理\n第一同构定理\n第二同构定理\n第三同构定理\n\nhttps://zh.wikipedia.org/wiki/%E5%90%8C%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86\n第一同构定理 (抽象代数) 又称 秩—零化度定理 (线性代数)\n第一同构定理:设 A 和 B 是两个代数结构，f 是 A 到 B 的态射，则 A 等价关系 R：a~b 当且仅当 f(a)&#x3D;f(b) 是 A 上的一个同余类，并且 A&#x2F;R 同构于 f 的像（B 的子代数）。\n\n\n秩－零化度定理:https://zh.wikipedia.org/wiki/%E7%A7%A9%E2%80%94%E9%9B%B6%E5%8C%96%E5%BA%A6%E5%AE%9A%E7%90%86\n它的秩（rank A）和零化度（nullity A）之和等于 n\n\n\n2. 双二元运算（S，+，*，0，1）：环：\n定义：\n\n加法群是阿贝尔群\n乘法群是独异点\n分配律\n\n\n有的理论认为：有些环可能没有乘法单位元，称为无单位环，而有单位元的环称为单位环。\n域\n定义：环有乘法单位元, 非零元都有乘法逆元，则该环是一个域。\n\n加法群是阿贝尔群\n乘法群是群（去掉 0，后不特殊备注）\n分配律\n\n\n\n注意\n\n域都是环：每个域都是环，因为它满足环的所有定义条件。\n环不是域：并非所有的环都是域。例如，整数环 Z 是一个环，但它不是域，因为整数的乘法中并不是每个非零元素都有乘法逆元（例如，2 在 Z 中没有逆元）。\n单位环：如果一个环有乘法单位元且每个非零元素都有乘法逆元，则该环是一个域。仅有单位元而没有逆元的环称为单位环。\n\n\n完备域\n完备域的定义:(https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%A4%87%E7%A9%BA%E9%97%B4)\n完备性：一个域 F 是完备的，如果每个有上界的单调递增序列都收敛到 F 中的某个元素。换句话说，完备域中的每个有界序列都有极限，这个极限也在该域中。\n口诀：有界集合必有上确界\n\n例子：实数（点击跳转到本页对应章节）\n\n3. 格（S，交，并）格\n考虑任意一个偏序集合（L,≤），如果对集合 L 中的任意元素 a,b，使得 a,b 在 L 中存在最大下界和最小上界，则(L,≤)是一个格\n\n\n另一种定义格的方式是将格定义为一种代数结构（S，交，并）. 满足：\n\n交换律\n结合律\n吸收律\n\n\n布尔代数有补分配格。\n\n定义：是格，且满足：\n\n分配律\n互补律\n\n\n\n二、例子 各个数字集正整数:\n加法群是可生成半群\n乘法群是半群\n\n自然数（Natural Numbers）：独异点\n加法群：独异点\n乘法群：独异点\n\n整数（Integers）：交换域群\n加法群：循环群（可生成群）\n乘法群：独异点\n\n\n每个元素个数为无穷个的循环群都与(Z, +)同构。\n\n\n是一个全序集，没有上界和下界\n\n\n全序关系 也称为线性顺序(S, ≤).\n\n反对称的\n传递的\n完全的(要么 a &lt;&#x3D; b, 要么 b &lt;&#x3D; 前段)\n\n\n有理数（Rational Numbers）：交换域\n加法群：阿贝尔群\n乘法群：阿贝尔群\n\n\n全序关系 也称为线性顺序(S, ≤).\n\n反对称的\n传递的\n完全的\n稠密性若 a &lt; b，则必存在有理数 c，满足 a &lt; c，且 c &lt; b。\n\n\n实数（Real Numbers）：完备域\n完备域（点击跳转到本页对应章节）:\n(https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%A4%87%E7%A9%BA%E9%97%B4)\n完备性：一个域 F 是完备的，如果每个有上界的单调递增序列都收敛到 F 中的某个元素。换句话说，完备域中的每个有界序列都有极限，这个极限也在该域中。\n口诀：有界集合必有上确界\n\n\n加法群：阿贝尔群\n乘法群：阿贝尔群\n\n","categories":["数学"],"tags":["离散数学","抽象代数","笔记","百科"]},{"title":"GPU 体系架构之争：SIMD 和 SIMT","url":"/2025/02/07/%E5%AD%A6%E4%B9%A0/%E6%A1%88%E4%BE%8B/simd-vs-simt/","content":"GPU 体系架构之争：SIMD 和 SIMT\nBV18WcNedETb\nhttps://www.bilibili.com/video/BV18WcNedETb\n\nSIMD 和 SIMT 的布局区别（以 8 线程 8 单元硬件为例）\n\nSIMD：2 个线程，每个线程 4 个运算单元。\nSIMT：8 个线程，每个线程 1 个运算单元。\n\n缺省向量如果只用到向量的 3 个分量（vec3），而不用第四个分量，那么\n\n\nSIMD 架构会有运算单元空转的情况发生，因为它一个线程必须霸占 4 个计算单元，但却只有 3 个分量需要计算，最终花费 4 个周期完成运算。\n而 SIMT 架构每次都处理 8 个线程的同一个分量，只需 3 个周期完成运算。\n\n条件分支\n每个线程运行不同的任务。这种情况下，由于条件分支的影响，多线程无法合并运算（GPU 核判断到不同线程的程序计数器不同，说明发生了条件分支，因此不会让多线程同时运行，即使都是加法运算，GPU 也没有这个进一步的推理能力（也不需要这种推理能力，否则运算性能大打折扣））。\n\n假设任务是：8 个线程，8 个向量，每个向量都是 4 分量向量的运算。总共要完成 8 * 4 = 32 个单元运算。\nSIMD 由于硬件线程只有两个，每个线程霸占 4 个单元，可以在一个周期完成一个线程的向量运算（4 分量向量）。总共要花费 32 / 4 = 8 个周期。\nSIMD 则因为 8 个线程均分了 8 个单元，每个周期又只能运行一个线程，因此每个周期只能运算 1 个向量的 1 个分量，总共需要 32 / 1 = 32 个周期。\n\n","categories":["案例"],"tags":["笔记","案例","GPU","并行计算"]},{"title":"密码文件不小心提交了 git？git filter-repo 快速解决！","url":"/2024/10/28/%E5%AD%A6%E4%B9%A0/%E6%A1%88%E4%BE%8B/%E5%AF%86%E7%A0%81git%E6%8F%90%E4%BA%A4/","content":"密码文件不小心提交了 git？git filter-repo 快速解决！首先，立即删除 github 仓库，并立即修改可能泄露的密码，防治安全隐患。\n当使用 git filter-repo 时，它会检查当前仓库的状态，防止在非干净的工作树上进行破坏性的历史重写。为了顺利进行，你可以按照以下步骤操作：\n解决方法创建一个新的克隆：\n\n首先，确保你的更改已提交或保存。安装 git-filter-repo\n\npip install git-filter-repo\n\n\n然后，克隆当前仓库到一个新的目录：\n\ngit clone /project /project/git-clone\n\n\n进入新克隆的目录：\n\ncd ./git-clone\n\n\n在新克隆的仓库中执行：\n\ngit filter-repo --invert-paths --path password.txt\n\n如果仍然希望在原仓库中执行：\n你可以在原仓库中使用 –force 选项，但请注意这可能会导致数据丢失：\ngit filter-repo --invert-paths --path password.txt --force\n\n注意事项\n备份：无论你选择哪种方法，确保在操作之前备份你的仓库，以防任何意外情况。\n审慎操作：使用 –force 选项会改变历史，谨慎操作并确保你理解后果。\n\n这样，你就可以在新的克隆中安全地移除敏感文件的历史记录。\n随后，重新发布到 github。\n","categories":["案例"],"tags":["案例","git","踩坑"]},{"title":"矩阵乘法最佳实现算法 （by CSAPP）","url":"/2024/11/06/%E5%AD%A6%E4%B9%A0/%E6%A1%88%E4%BE%8B/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","content":"矩阵乘法最佳实现算法 （by CSAPP）背景\n注意看，这个男人叫矩阵乘法定义式\n\n\n\n\n\nC[m, n] +&#x3D; A[m, k] * B[k, n]\n\n不难写出一个 python 程序来实现：\nfor m in range(M):    for n in range(N):        for k in range(K):            C[m, n] += A[m, k] * B[k, n]\n\n但是，\n这是最快的算法吗？\n不是。\n推理过程最基础的算法如上，这里 copy 过来：\nfor m in range(M):    for n in range(N):        for k in range(K):            C[m, n] += A[m, k] * B[k, n]\n\n我们画图思考一下，数据的访问顺序\n这是普通人能想到的，最简单算法。\nA 的局部性原理利用的很好，所以很快。\n但是 B 的局部性原理排第二，B 是按照列来访问的。这很慢。跨越了局部性 cache\n所以 B 也应该按照行访问。但是公式是死的。\n\nC[m, n] +&#x3D; A[m, k] * B[k, n]\n\n我们注意到，对于 C 来说，虽然没有使用 k，但它也是满足局部性原理的\n我们的最终目的是，优先按行访。问也就是优先迭代 n, k ,n。这似乎是矛盾的。\nk 是 A 的列索引（2 级索引），B 的行索引（1 级索引）。不可能最优先访问。所以就有了第二个想法。迭代顺序为： m-&gt;k-&gt;n\nfor m in range(M):    for k in range(K):        for n in range(N):            C[m, n] += A[m, k] * B[k, n]\n\n那么这是不是最快的呢？\n\n这样我们实现了 BC 的按行访问\n那么 A 呢？\n由于 m 仍然在 k 外层：M -&gt; K -&gt; N所以 A 也是按行访问的 。\n其实所有的迭代顺序种类为 A(3, 3) &#x3D; 3! &#x3D; 6\nCSAPP 测试了所有访问顺序，我们就不必再测了。\n由于我们有三个行索引（1 级索引）：m, m, k，三个列索引（2 级索引）：n, k, n\n所以，只要满足：任取行索引 x，列索引 y，使得 x 在 y 的外层 成立，就是最快算法；反之是最慢算法。\n重要表格所以所有算法的排序为\n\n\n\nrank\n访问顺序\nm &gt; n\nm &gt; k\nk &gt; n\nscore\n\n\n\n1\nm-&gt;k-&gt;n\n1\n1\n1\n3\n\n\n2\nk-&gt;m-&gt;n\n1\n0\n1\n2\n\n\n2\nm-&gt;n-&gt;k\n1\n1\n0\n2\n\n\n3\nn-&gt;m-&gt;k\n0\n1\n0\n1\n\n\n3\nn-&gt;m-&gt;k\n0\n1\n0\n1\n\n\n4\nn-&gt;k-&gt;m\n0\n0\n0\n0\n\n\n\n\n\nm\nn\nk\n\n\n\n1 级索引\n2 级索引\n1 级索引+2 级索引\n\n\nC[m, n] +&#x3D; A[m, k] * B[k, n]\n结论因此，最快矩阵乘法为\nfor m in range(M):    for k in range(K):        for n in range(N):            C[m, n] += A[m, k] * B[k, n]\n","categories":["案例"],"tags":["笔记","案例","数学","算法"]},{"title":"CS149-并行计算-斯坦福大学-学习笔记","url":"/2025/01/17/%E5%AD%A6%E4%B9%A0/%E6%80%BB%E7%BB%93/CS149/CS149-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6/","content":"CS149-并行计算-斯坦福大学-学习笔记\n讲师: Kayvon Fatahalian, Kunle Olukotun\n课程录播（中英字幕，部分有误，fall 23）：https://www.bilibili.com/video/BV1du17YfE5G\n课程官网（fall 24）：https://gfxcourses.stanford.edu/cs149/fall24\n编程作业（fall24）：\n在四核 CPU 上分析并行程序性能\n在多核 CPU 上调度任务图\n用 CUDA 实现一个简单的渲染器\n在 DNN 加速硬件上优化深度神经网络（DNN）性能。（实现和优化 AWS Trainium 架构的内核）\n使用 OpenMP 处理大规模图数据\n（fall23 第 4 题）chat149: 小语言模型，用 C++ 实现基于 DNN 的 transformer 的注意力层（flash-attention）\n\n\n\n\n（fall24）课程导言：从智能手机到多核 CPU 和 GPU，再到世界上最大的超级计算机和网站，并行处理在现代计算中无处不在。本课程的目标是深入了解设计现代并行计算系统所涉及的基本原理和工程权衡，并教授有效利用这些机器所需的并行编程技术。因为编写好的并行程序需要了解关键的机器性能特征，所以本课程将涵盖并行硬件和软件设计。\n\n\n目录\n其一：Why Parallelism? Why Efficiency?\n其二：A Modern Muti-Core Processor\n其三：Multi-Core Architecture Part II + ISPC Programming Abstractions\n其四：Parallel Programming Basics\n其五：Performance Optimization I: Work Distribution and Scheduling\n\n\n其一：Why Parallelism? Why Efficiency?\n第一章：为什么要并行？为什么要高效率？\n\n\n摘要：并行化代码的挑战、并行芯片的动机、处理器基础\n\n\nFast !&#x3D; Efficient\n速度快，不等于效率高\n\n\n如果老板给了你 100 倍的算力设备，你却仅仅将程序加快了 2 倍，我想你就该被开除了。\n“是的，让他去重修 CS149。”\n\ndemo1：第一个并行程序\n案例：\n\n1 人可以在 45 秒内算出 16 个数的总和。（demo1：第一个并行程序）\n但 2 人并不能在 23 秒内算出 16 个数字的总和，而是 40 秒。\n4 人计算 16 个数字之和的时间，优化到了 19 秒，而不是 12 秒。（demo2：扩展到 4 个“处理器”）\n100 多人不能在 2 分钟内数清楚人数总和。（demo3：大批量并行执行）\n\n\n这个案例告诉我们：并行计算，关键不在于如何并行，如何计算（虽然这也很重要），关键在于数据传输和协同效率。\n因此，我们更多的是在学习：如何传输数据，排列数据，而不是写代码或布局硬件。\n什么是计算机程序？ What is a computer program ?\nA program is a list of processor instructions!\n\n“程序（program）”不同于“代码（code）”。\n程序，与食谱一样，应当是可执行的一系列命题（操作流程）。\n计算机程序，则是“指令流”，或者叫“指令序列”。必须是计算机认识的一系列 01 串。\n处理器做了什么？ What does a processor do ?一个简化的处理器有 3 个模块：\n\nFetch &#x2F; Decode： 取指令、解析指令\nALU：算数运算单元\nExecution Context：执行上下文\n\n案例：a = x * x + y * y + z * z这个简单的多项式运算会编译出 5 条指令（假设使用 r1，r2，r3 寄存器，假设不使用任何编译优化编译优化（ChatGPT））：\n\nmul r1, r1, r1\nmul r2, r2, r2\nmul r3, r3, r3\nadd r1, r1, r2 ; r1 &#x3D; r1 + r2\nadd r1, r1, r3\n\n我们发现，指令 4 依赖于指令 1、2；指令 5 依赖于指令 3、4。所以，等待是必须的，即使使用 5 个 cpu，效率也不会超过 1 条 mul 指令时间加上 2 条 add 指令时间。\n（这里还有寄存器最少使用原则，或最多使用原则，不做讨论）\n如何进一步提高性能？\n\n数学家：改进数学公式，减少乘法次数（耗时长的操作），增加加法次数（耗时短的操作），重新编写代码。\n硬件工程师：指令重排，指令随机化，指令流水线，分支预测，多级缓存，自动并行化，自动向量化加速\n软件工程师：编写高维度的，可并行化的程序。任务并行化，数据结构并行化，计算并行化，数据传输并行化，数据存储并行化。主动使用缓存（预存器）。\n\n\n小结\n\n软件：物尽其用（压榨硬件的一切性能）\n硬件：用尽其物（挑选更好的硬件去适配软件）\n\n\n编译优化（ChatGPT）现代编译器通常会结合多种优化策略，来提高程序的执行效率。它们会根据不同的场景、硬件架构和程序的特征，选择不同的原则来优化寄存器的使用。以下是一些现代编译器普遍采用的优化原则和策略：\n1. 寄存器最多使用原则（Maximizing Register Usage）现代编译器在许多情况下倾向于使用尽可能多的寄存器，这样可以减少对内存的访问，因为寄存器的访问速度远快于内存。这个原则通常用于以下情况：\n\n频繁访问的变量：如果某个变量在计算中被频繁使用，编译器会尽可能地将其保留在寄存器中，避免频繁的内存读写操作。\n局部性原理：寄存器的使用能很好地利用数据的局部性。例如，如果某个数据在一段时间内频繁访问，它可以存储在寄存器中，而不需要每次从内存中读取。\n\n举例：对于一个简单的多项式计算：\na = x * x + y * y + z * z;\n\n编译器可能会为每个中间结果（如 x * x、y * y、z * z）分配一个寄存器，并将结果存储在寄存器中，避免额外的内存操作。\n2. 寄存器分配和寄存器重命名\n寄存器分配：编译器通过分析程序的数据流和生命周期来确定哪些变量应该保留在寄存器中。寄存器的分配不仅考虑变量的使用频率，还要避免寄存器冲突，尽可能地减少寄存器的交换和保存操作。\n寄存器重命名：现代编译器会使用寄存器重命名技术来避免因寄存器依赖（如数据依赖）而产生的性能瓶颈。通过给同一个物理寄存器分配多个逻辑寄存器，编译器可以让多个指令并行执行，避免等待依赖关系完成。\n\n3. 局部变量优化现代编译器通常会通过 局部性分析 来优化寄存器的使用。局部变量是那些只在函数内部使用的变量，编译器会尽量将它们分配到寄存器中，而不是存储在栈上或堆上。特别是对于小型的、生命周期较短的局部变量，寄存器使用能显著提高性能。\n举例：\nint sum = 0;for (int i = 0; i &lt; N; i++) &#123;    sum += arr[i];&#125;\n\n编译器可能会将 sum 和 i 变量都存储在寄存器中，以减少对内存的访问。\n4. 内联扩展（Inlining）编译器会尝试对一些小的、频繁调用的函数进行内联扩展（inline），将函数调用替换成函数的实现体。这可以消除函数调用的开销，并减少对寄存器和内存的使用，特别是在递归或频繁调用的情况下。\n5. 循环优化（Loop Optimization）编译器对循环结构进行优化，以提高寄存器的利用率和减少内存访问。例如，编译器可能会将循环展开、循环重排或循环分割，以便使计算更密集，从而减少内存的读取次数。\n举例：\nfor (int i = 0; i &lt; N; i++) &#123;    a[i] = b[i] + c[i];&#125;\n\n编译器可能将其优化为多个操作并行执行，或者将内存访问合并，以更高效地利用寄存器。\n6. 寄存器压力和溢出（Register Pressure and Spill）现代编译器会根据寄存器的使用情况动态调整优化策略。如果寄存器使用过多，导致“寄存器压力”过大，编译器就可能将某些值溢出（spill）到栈上，特别是在寄存器资源紧张的情况下。溢出操作会影响性能，因为它需要额外的内存读写操作。\n7. 自动向量化现代编译器（如 GCC、Clang、Intel 的 ICC 编译器等）支持自动向量化。通过向量化，编译器可以将标量操作转化为 SIMD（单指令多数据流）操作，这样能够将多个计算任务并行地放到同一个寄存器组中，从而大幅提高计算效率。\n举例：\nfor (int i = 0; i &lt; N; i++) &#123;    a[i] = b[i] + c[i];&#125;\n\n如果编译器支持向量化，它可能会将这段代码转换成可以同时加法多个元素的 SIMD 指令，使得多个数组元素能够同时在寄存器中处理，从而提高性能。\n8. 多级缓存和数据局部性现代编译器也会考虑缓存的优化，尽量减少从内存中读取的数据量，利用 CPU 的多级缓存（L1、L2、L3 缓存）。通过优化程序的数据访问模式和寄存器分配，编译器能够使数据尽可能保持在较快的缓存中，而不需要频繁访问较慢的主内存。\n9. 并行计算和多核优化在多核处理器上运行时，编译器可能会自动将程序分割成多个并行线程，使用多核的并行性来加速计算。寄存器的分配和使用会考虑到多线程并发执行的情况，确保每个线程能够高效地利用本地寄存器。\n10. 指令级并行性（ILP）优化编译器会使用一些高级技术（如指令重排、延迟槽填充、分支预测等）来优化指令级并行性。这些优化措施通过重新排列指令，减少指令间的依赖关系，从而更好地利用寄存器和其他硬件资源，提高程序的执行效率。\n总结现代编译器会综合考虑性能、内存带宽、寄存器数量、计算依赖关系等多种因素，使用寄存器最多使用原则来最大化寄存器的利用率，但也会根据具体的硬件架构和程序的特性做适当的调整。最终目标是减少内存访问、提高并行性，并通过智能的寄存器分配和优化技术提升整体性能。\n其二：A Modern Muti-Core Processor\n第二章：现代多核处理器\n\n\n摘要：并行形式：多核、SIMD 和多线程\n\n案例：计算 y[i]=sin(x[i])void sinx(int N, int terms, float* x, float* y)&#123;    for (int i=0; i&lt;N; i++)    &#123;        float value = x[i];        float numer = x[i] * x[i] * x[i];        int denom = 6; // 3!        int sign = -1;        for (int j=1; j&lt;=terms; j++)        &#123;            value += sign * numer / denom;            numer *= x[i] * x[i];            denom *= (2*j + 2) * (2*j + 3);            sign *= -1;        &#125;      y[i] = value;    &#125;&#125;\n\n这段程序计算 y[i] = sin(x[i])，N 为数组长度，terms 则是精度（泰勒展开项个数）。\n暂且不谈这段程序在优化方面，利用了之前的计算结果来计算 x 的幂次与 j 的阶乘，这种做法的精妙之处，以及使用 for 循环和局部变量，而不是函数，带来的更高程度的局部性，也不考虑运算溢出问题。我们只关心，如何并行化计算。\n高维度并行化（调用方并行）typedef struct &#123;    int N;    int terms;    float* x;    float* y;&#125; my_args;void my_thread_func(my_args* args)&#123;  sinx(args-&gt;N, args-&gt;terms, args-&gt;x, args-&gt;y); // do work&#125;void parallel_sinx(int N, int terms, float* x, float* y)&#123;  std::thread my_thread;  my_args args;  args.N = N/2;  args.terms  = terms;  args.x = x;  args.y = y;  my_thread = std::thread(my_thread_func, &amp;args); // launch thread  sinx(N - args.N, terms, x + args.N, y + args.N); // do work on main thread  my_thread.join(); // wait for thread to complete&#125;\n\n其中 sinx() 的定义同上。\n老师给出的代码，实现了 main 线程和子线程并行计算一串 y[i]=sin(x[i])。主线程计算后半段，子线程计算前半段。用指针运算，巧妙地在调用方进行了并行化（即老师所说“更高维度的并行化”）。\n但是，并不是所有程序都能做到这样良好的并行化。\n向量编程（底层并行）AVX intrinsics\n条件分支\n在现代向量运算器上，比如 8 个单元的 ALU，并不是每个单元都能有效利用（每个单元都有自己的数据要处理，有自己的条件判断分支）。程序不可避免需要 if else 语句，这就导致有的时候我们并不能充分发挥并行计算的全部性能（也就是没做到“物尽其用”的硬件性能压榨）。\n老师问：有没有一种 if 语句，能让并行化的性能反而降低为 1&#x2F;8？\n答案是：if 里进行模 8 判断，在 1&#x2F;8 的情况下进入代码块 1，在 7&#x2F;8 的情况下进入代码块 2，但代码块 1 所做的事情是代码块 2 的很多很多倍（极端情况是代码块 1 执行所有计算，代码块 2 不执行计算），这样总体性能就约等于 1&#x2F;8。\n为了避免在大多数情况下进入低性能运算分支，我们应当仔细考察运算过程，写出“高并行化”的“高性能”代码。\n现代多核处理器3 种不同形式的并行执行\n超标量（Superscalar）：利用指令流中的 ILP。并行处理同一指令流中的不同指令（只用一个核心（core））。\n在执行过程中，硬件自动发现并行性。（发现一小段程序中有几条指令可以并行执行）\n\n\n单指令流多数据流（SIMD）（Single Instruction Multiple Data）：一条指令控制多个 ALU（只用一个核心）。\n高效处理数据并行工作负载：摊销对多个 ALU 的控制成本。\n由编译器（显式 SIMD）或在运行时由硬件（隐式 SIMD）进行向量化\n\n\n多核（Multi-core）：使用多个处理核心\n提供线程级并行：在每个核上同时执行完全不同的指令流\n软件创建线程以向硬件公开并行性（例如，通过线程 API）\n\n\n\n现代多核处理器回顾一下第一章的简单处理器架构：\n\nFetch &#x2F; Decode： 取指令、解析指令\nALU（Execution）：算数运算单元（执行器）\nExecution Context：执行上下文\n\n简单扩展一下，利用前面提到的三种并行化策略，我们就可以得到：\n\n单核、超标量处理器：\n2 个取指器&#x2F;解析器\n每个取指器对应 1 个执行器\n多个执行器共用一个上下文\n\n\n多核处理器：\n就是多个核心复制粘贴（不考虑数据、缓存交流等）\n\n\nSIMD 四核处理器（八位宽）：\n4 个核心\n每个核心 1 个取指器\n每个核心 8 个 ALU（8-wide SIMD）\n每个核心 1 个上下文\n\n\n\n\n\n\n四核 Intel i7-7700k CPU:\n4 核心\n每个核心 1 个上下文\n每个核心有 3 个 8 位宽 SIMD ALUs（AVX2 instructions）（每个核心 3 个取指器，每个取指器 8 个 ALU）\n浮点运算性能：4（核） * 8（位宽）* 3（个）* 4.2Ghz &#x3D; 400GFLOPs\n\n\n\n\n\n\nNVIDIA V100 GPU\n80 个“SM（Streaming Multiprocessor）” 核心\n128 个 SIMD ALUs 每”SM”(@1.6 GHz)&#x3D;16 TFLOPs (~250 Watts)\n\n\n\n第二部分：访问内存（Part2：accessing memory）回想：非常长的数据访问延迟延迟（在 4GHz 下的时钟周期数）\n\nL1 Cache：4\nL2 Cache：12\nL3 Cache：38\nDRAM：~248\n\n回想：缓存未命中\n冷启动未命中（Cold Miss &#x2F; Compulsory Miss）\n容量未命中（Capacity Miss）\n冲突未命中（Conflict Miss &#x2F; Collision Miss）\n一致性未命中（Coherence Miss &#x2F; Invalid Miss）\n人为失效未命中（Manual Invalidation Miss）\n\n回想：数据预取当访问大量连续性可预测的数据，比如访问一大块数组时，可以很容易进行预测，并进行数据预取（data prefetch）\n\n但是，如果近期没有访问过数据，也很难预测程序下一步要干嘛，怎么办？\n第 3 种方法：用多线程隐藏停顿（hide stall）就像可以边烧水边炒菜一样，当我们知道某种操作耗时，我们就先去处理别的事情。\n\n等水烧开，再去关火。\n\n多线程，就是复制我们之前提到的处理器架构中的“上下文”。\n\n线程 1：计算，访问内存，计算。\n线程 2：计算，访问内存，计算。\n线程 3：计算，访问内存，计算。\n线程 4：计算，访问内存，计算。\n\n使用一个核心，我们可以创建 4 个线程，按顺序执行这些线程。当线程 1 访问内存、等待数据的时候（前面提到的大约 250 个时钟周期），让线程 2 进行计算操作，当线程 2 访问内存、等待数据的时候，让线程 3 进行计算…\n由此，我们得到了大致的多线程执行时间流：这个程序的 cpu 利用率为：100%\n我们并没有减少停顿时间，我们只是在停顿时间内去做别的工作。\n\n等待，但不仅仅是等待\n\n\n边等待，边计算\n\n多线程，具体多少线程？继续回想案例：计算一组 y[i]=sin(x[i])\n假设：计算耗时 20%，传输数据耗时 80%。\n假如只有一个线程，那么 cpu 有 80% 的时间在 stall（停顿），也就是等待内存读写（load&#x2F;read memory）。\n如果有 5 个线程，那么在 1 个线程等待数据的 80%时间内，剩下的 4 个线程可以完全占用 cpu，当数据传输完毕，线程 1 回归计算操作，cpu 利用率达到了 100%，耗时缩短为原来的 20%，从耗时结果上看，我们“隐藏了停顿”。\n更多的线程不会带来更多的性能提升，cpu 利用率已经到了 100%，再增加线程反而会因为上下文切换，导致耗时更多。\n\n那么，当计算耗时占比为 x（x∈(0, 1)）时，应该设置几个线程？\n先想象一个线程在执行，数据传输时间占比为：1-x\n为了占满（cover）等待时间，我们需要几个额外的线程呢？\n那当然是 (1-x)/x 个啦。\n所以总线程数是：y = (1-x)/x + 1 = 1/x\n\n结论：当计算时间占比 x，线程数应设置为 ceil(1/x)。（ceil：向上取整）\n\n硬件多线程Hardware-supported multi-threading硬件支持的多线程\n\n硬件核心管理多个线程的执行上下文\n核心仍然拥有相同数量的 ALU 资源：多线程只有助于更有效地使用这些资源，在面对内存访问等高延迟操作时\n处理器决定每个时刻运行哪一个线程\n\n\n交错多线程（也称时间多线程）Interleaved multi-threading (a.k.a. temporal multi-threading)\n每个时钟，核心选择一个线程，并运行这个线程的一条指令，在核心的 ALUs 上\n\n\n同步多线程Simultaneous multi-threading (SMT)\n每个时钟，核心从多个线程中选择多条指令在 ALUs 上运行\n示例：英特尔超线程（Hyper-threading）（每个内核 2 个线程）\n\n\n\n你应该知道的一些术语\n指令流 Instruction stream\n多核处理器 Multi-core processor\nSIMD 执行 SIMD execution\n一致控制流 Coherent control flow\n硬件多线程 Hardware multi-threading\n交错多线程 Interleaved multi-threading\n同时多线程 Simultaneous multi-threading\n\n\n\n回想：烹饪过程\n当你需要等待一件事，那你就去做另一件事\n\n多线程为什么能提高效率？本质是通过 停顿时切换（switch on stall），也就是在停顿时干别的事，消除了停顿时间。\n在停顿、等待时，切换任务，去干别的事情，保证计算机资源充分利用，“压榨硬件性能”、“物尽其用”。\n现代处理器例子：Kayvons 虚构的多核芯片现在，我们假想有一个处理器，性能参数如下：\n\n16 核心\n8 SIMD ALUs 每核心（共 128）\n4 线程 每核心（共 64 线程）（硬件多线程）\n16 最大并行（simultaneous）指令流\n64 最大并发（concurrent）指令流\n那么需要创建 512 个任务（task），如果你要完全“隐藏”延迟\n\n例子：Intel Skylake&#x2F;Kaby Lake core\n\nSkylake 微架构（第六代 Intel Core）\n发布时间：2015 年\n制程工艺：采用 14nm 工艺。\n支持 DDR4 内存：首次支持 DDR4 内存（同时兼容 DDR3L），大幅提升内存带宽。\n微架构更新：\n执行单元优化：增加了调度器和缓冲区大小，提升多线程性能。\n分支预测增强：改进了分支预测算法，减少错误预测的开销。\n更深的流水线：更高的指令并行性，使得单核性能（IPC）显著提升。\n三级缓存改进：更高效的共享缓存，提高多核间的数据访问速度。\n\n\n\n\n这张图是 Intel Skylake&#x2F;Kaby Lake 架构 CPU 的其中一个核心 Core 0.双路多线程核心（2 线程）。每个核心最多可以同时运行 4 个独立的标量指令和 3 个 8 宽的向量指令（最多 2 个向量相乘或 3 个向量相加）\n\n学生：双线程可以同时运行？但我们仍然需要按顺序取指令？额外的取指器&#x2F;解码器是如何起作用的？\n老师（Kayvon）：宽松地讲，可以想象这群取值器&#x2F;解码器看作一个高级的取值和解码单元（”fancy fetch and decode unit”），它们有能力把“一堆指令”塞满“一堆执行单元（a bunch of execution units）”，取指器&#x2F;解码器的操作是，从 Thread0 中找一些指令，在 Thread1 中找到一些指令，然后我有很多黄框框（ALUs）需要被填满，我要做的就是尽可能地用指令填满这些黄框框，来充分利用 CPU 的计算性能（ALUs）。\n“every thing here composes”，在这个芯片上，一切都组合在了一起这个芯片是一个：\n\n超标量芯片（Superscalar）\nSIMD 芯片\n硬件同时多线程芯片（Intel 超线程）\n多核芯片\n\n\n我的补充：\n\n然而有的指令是标量，有的是向量，有的指令有依赖关系，有的指令可以并行执行但间隔太远，它们并不一定能并行，这取决于程序。\n程序（指令流）并不会按顺序执行，因为很可能你写的程序编译后，可并行性差得要命！因此，现代处理器会乱序执行。\n早期超线程技术中，会有缓存问题。比如线程 1 修改了线程 2 的缓存，导致缓存失效需要重新读取。有时，减少线程数会有利于应用程序更好地运行。\n即使是目前，超线程技术仍存在安全问题。因此，一些安全专家建议全面禁止超线程。\n\n例子：NVIDIA V100 GPU\n共 80 个“SM（Streaming Multiprocessor）” 核心\n每个 SM 有 64 个 warp 执行上下文\nSIMD ALUs 位宽为 16，启动 2 个时钟周期后为 32\n64 \\* 32 = 2048 最大数据并发量&#x2F;SM\n\n80 \\* 2048 = 163840 最大数据并发量（每个时钟周期）（另注：不是并行，并行量略低）\n\n[!NOTE]并行计算性能为：FP32 性能 &#x3D; CUDA 核心数 × 时钟频率 × 每个核心每周期的运算\nFP32 性能 &#x3D; 5120 × 1.53GHz × 2 = 15.7 TFLOPS &#x3D; 15.7 * 10^12 FLOPS\n大约每秒 16 万亿次 32 位浮点运算\n\n仅在硬件级别，就提供了 16 万的并发量。这还没有考虑，实际任务的计算耗时与数据传输耗时占比，为了完全覆盖停顿时间，所需要的额外线程数。如果仍然使用计算 sinx 的任务来占满这个芯片，除非你有成千上万的数据要处理，否则还是别费劲了。这就是为什么一个小型 DNN 在大型 GPU 上运行不佳。\n\n因为我们没有足够多的任务去塞满它\n\n如何高效利用现代处理器？为了高效地利用现代并行处理器，必须：\n\n有足够多的并行工作来利用所有可用的执行单元（跨多个核心和每个核心的多个执行单元）\n并行工作任务组必须要求相同的指令顺序（利用 SIMD 执行）\n（软件要向硬件）暴露比处理器 ALUs 数更多的并行工作数目，来保证并发能够隐藏内存停滞。\n\n多线程的另一个作用：塞满计算单元继续设想一个处理器，他的 ALUs 支持 4 个标量指令和 3 个向量指令。\n假如单线程运行，硬件最多只能发现 2 个标量可以并行（或者 2 个向量指令，或者 1 个标量 1 个向量），因为其他指令有依赖关系或者相距过远无法并行。\n当双线程运行，硬件可能就会在 thread0 找到 2 个标量指令，在 thread1 找到 2 个向量指令，然后同时运行它们。\n当线程数来到 4 个，处理器很聪明的找到了 4 个标量指令和 3 个向量指令，然后把它们塞满 ALUs，这样，这个虚构处理器就达到了最高的利用率。\n我们就知道了乱序执行（指令重排）的好处之一：原本由于相距过远无法并行的指令，打乱顺序后紧挨在了一起，就可以并行了（在没有依赖关系的条件下）。\n那如果有依赖关系呢？\n\n内存屏障：处理器会通过内存屏障（读、写、全屏障）等技术确保逻辑无误。\n寄存器重命名：通过寄存器重命名技术，处理器可以消除伪依赖关系，从而提高并行度。\n\n\n[挖坑]Kayvon 老师：但是 AMD 和 NVIDIA 的 GPU 工作方式略有不同\n\nGPU SIMT(Single Instruction Multiple Thread)大部分现代 GPU 永远都只会编译生成标量指令（scalar instruction）\nGPU 核会检测硬件线程的执行指令是否相同（通过判断程序计数器（pc）），如果相同，就用一个向量指令来代替原本的多个相同的标量指令。\n假设一个 GPU 核心有一个 8 位宽的向量 ALUs（可以同时计算八个操作）。假设有 8 个线程，每当这 8 个线程的程序计数器（pc）相同，那么就在这 8 位宽的向量运算器上同时运行这 8 个指令这与编译了一个 8 位宽 SIMD 向量操作效果相同。\n那么如果有 7 个线程的 pc 相同，仅有一个线程不同呢？\n那个线程会被 “masked off”（屏蔽）。（回想：第二讲中的条件分支）\n思考题你写了一个 C 语言应用程序，生成了 2 个线程\n你的应用程序运行在如下处理器上：\n\n2 个核心，每个核心 2 个执行上下文，每个时钟最多执行 （ ） 条指令，一条指令是 8 宽的 SIMD 指令。\n\n问题 1：谁负责将应用程序的线程映射到处理器的线程执行上下文?\n\n答：操作系统（Operating system）\n\n\n问题 2：如果你来实现一个操作系统，那么如何将这 2 个线程分配给 4 个执行上下文？\n\n问题 3：如果您的 C 程序派生了 5 个线程，如何分配给执行上下文？\n\n如果是两个截然不同的线程，把他们都分配到一个核上显然是不太合适的\n那如果这俩线程需要访问相同的数据呢？想要共享缓存或者其他资源呢？答案可能恰恰相反\n\n\n\n\n学生：现在我们有多个执行上下文，那么如何决定是使用硬件多线程还是使用超标量架构？\nKayvon：这是芯片（chip）实现的细节，不是操作系统的任务。\n操作系统会说：“hey，chip！请你给我在 core1 上运行 thread3。”\n芯片会在每个时钟周期，根据自己拥有的执行上下文，决定执行哪些指令，如何执行，这个决策每秒数亿次，都发生在硬件中。\n操作系统还可能这样说：“你要 8 个线程来塞满你对吧。好，这是我从 1000 个准备好的用户线程中挑选的 8 个，你先给我执行一下子。”\n这就是操作系统级别的上下文切换。这种操作大约耗时十万个 cycles（时钟周期），且发生频率很低。\n\n\n学生：有没有办法让编译器强制执行一些行为？\nKayvon：是的。现代操作系统有 APIs，可以指定一个线程在特定的执行上下文中运行。\n学生追问：哦不，只是强制执行超标量架构的与否。比如说我就是不想乱序执行，不想让多个运算器协作\nKayvon：据我所知，这不是你可以过多干预的事。当然，你可以说你想关闭超线程这一功能，这很简单。如果你要干预处理器调度细节，据我所知，我并不清楚你有多少控制权。也许在 BIOS 级别可以，但在标准 OS 中可能不行。\n\n其三：Multi-Core Architecture Part II + ISPC Programming Abstractions\n第三章：多核架构第二部分（延迟&#x2F;带宽 问题） + ISPC 编程概述\n\n\n摘要：完成多线程和延迟与带宽。ISPC 编程、抽象与实现\n\n思考题：C[i] &#x3D; A[i] * B[i]假如有两个非常长的数组，成千上万。那么，它们之间的加法或者乘法计算，并将结果存入 C 数组中，这个计算是否适合在现代的面向吞吐量的并行处理器上执行？\n你会觉得这个向量运算太适合在现代处理器上执行了，现代处理器不就是向量优化的嘛？\n但实际上，这可能是一个最糟糕的程序，在现代处理器上，然后你每天都会运行它。\n为什么？\n想象一下，这些数据存放在哪里？硬盘上。\n\n最新的闪存固态硬盘，传输速率也不超过 64GB 每秒（PCIe 5.0）\nNvidia V100 的计算性能大致为 16 万亿次浮点运算每秒。\n\n假如我们正好需要算 16 万亿个浮点运算。也就是说，我们有 2\\*16 = 32 万亿个数字存放在硬盘上，需要花费大量时间（4*16TB / 64GBps = 8ks = 2.3小时）搬运到我们的 V100 上，然后 V100 花了一秒就算完了，接着我们又要花 2 个小时把数据搬回去。\n是什么限制了并行计算效率？\n带宽。\n带宽 Bandwidth101 公路假设 101 号公路连接着旧金山和斯坦福，\n\n为了简便运算，全长约为 50 km。\n假设我们都以 100 km&#x2F;h 的速度行驶。\n\n问题 1：通行（延迟（Latency））时间是多少？\n答：半个小时\n为了保证安全，比如防止追尾，我们添加一条新的规则（初版）:\n\n只允许一辆车占用这条公路.\n\n问题 2：那么每小时吞吐量为？\n答：每小时 2 辆车。\n那么如何优化吞吐量呢？\n\n方法 1：开快点。\n如果提速到 200km&#x2F;h，就可以每小时通行 4 辆车！\n\n\n方法 2：多建车道（lanes）。\n把 101 公路增加到 4 车道，每小时就能通行 8 辆车！\n\n\n方法 3：修改规则，允许同一车道开多辆车。\n允许车间隔至少 1km，同时占用同一车道，既保证了安全，又增加了吞吐量。现在，每小时可以通行 100 辆车！\n\n\n\n内存带宽\n内存带宽是一个速率 – 单位时间内完成多少事情。\nMemory bandwidth is a rate– how many things are completed per unit time.\n\n假设我现在有一个内存到处理器的带宽例子：\n原始的：\n\n假设我每秒发射 4 个方块\n那么现在带宽就是：4 items&#x2F;sec\n\n带宽增加的：\n\n我可以通过一次发射 2 个项目来增大带宽\n现在带宽来到了：2 * 4 = 8 items&#x2F;sec\n\n我们会发现，带宽和延迟成为了不同的两个概念。我们会在之后多次提到 流水线 这个词，就像在 101 公路上多车道塞满车运行一样，吞吐量 或者说 带宽 是可以远远超出 延迟 的限制的\n\n带宽 !&#x3D; 延迟\n\n例子：洗衣服操作：洗衣服\n\n洗（洗衣机） 45 min\n烘干（烘干机） 60 min\n折叠（大学生） 15 min\n\n在这个例子中，洗衣服的 延迟 是 2 小时，但吞吐量是多少呢？\n如果我们只洗 2kg 衣服（假设洗衣机容量是 2kg 衣服），那吞吐量就是每 1 kg&#x2F;h。\n如果我们有 4kg 衣服要洗呢？\n你可以再买一套洗衣机+烘干机，再叫上你的好伙计，然后并行进行两堆衣服的洗烘叠三步骤。最后骄傲地说：“嘿，瞧，我们把效率提高到了 2 倍！”\n我想，傻子都不会这么做。\n假如有很多堆衣服要洗，正常人都会这样做：在第一堆衣服洗完烘干后，把第二堆衣服（在洗衣机里洗好的）送进烘干机，把第三堆衣服送进洗衣机洗。\n\n因为，我们始终都想要填满 流水线 上的每一个单元。\n\n所以，我们不希望 cpu 闲置，ALUs 闲置，或者很多线程在等待执行。当然，我们也不希望洗衣机或烘干机在洗一堆衣服时处于闲置状态。\n那么，流水线工作的洗衣机和烘干机，整体系统的吞吐量（Throughput）是多少呢？\n可以看到，烘干机一直在拖后腿，洗衣机早就洗好了，他们的差距越来越大，系统吞吐量不会超过 1 load&#x2F;hour，这也正是烘干机的工作时间 – 1 hour。\n\n短板效应流水线中最慢的单元限制最大吞吐量\n\n试想一下，如果计算机各个单元也这样不匹配，数据就会像衣服一样，逐渐“堆满”有限的缓冲区（烘干机的机体上&#x2F;计算机的缓冲区），直到挤爆缓冲区，把电脑卡死，这是非常荒谬的。\n回想计组中的指令流水线：取指、译码、加减乘除、读取、写回。在计算机组成中，我们的做法是：更多的洗衣机，更少的烘干机（更多的 ALUs，更少的取指器）\n这个例子中，洗衣机和烘干机的速度比例是 1/45 : 1/60 = 4:3 ，所以我们最好用速度的反比 3:4 的比例来配置洗衣机和烘干机的数量，以防止衣服堆积在中间。\n回想：案例：C[i] = A[i] * B[i]现在，让我们回到计算机的视角：处理器很快，但内存带宽限制了系统的吞吐量。内存带宽就像那个烘干机，一直拖后腿。最先进的 NVlink 传输速率是 900GB&#x2F;s。\n假如在 V100 上运行这个程序，每个数学运算都需要 12 个字节（3 个 4 字节的浮点数），V100 的每秒浮点运算次数约为 16 万亿次，每秒钟，我们需要大约 100TB 的数据，但最先进的 NVlink 技术也只能达到 900GB&#x2F;s 的传输速率。\n可以理解为：你的洗衣机比烘干机块一百倍。\n所以，这个程序在 V100 上运行的效率是 **小于 1%**。\n此时，缓存没有用，缓存只在重复读取时有用。\n\n如果你只是想做这样的一次性简单向量运算，那么面对 1% 的超低效率，你无能为力。\n除了改变你的程序，或者等待更快的内存系统出现，你别无选择。\n\n\n这个程序是 带宽限制 的（bandwidth limited）。\n\n那能不能增加“车道（lanes）”呢？\n很遗憾，就像现实中都很少有 8 车道一样，专家们也受到物理上的限制和系统总线的限制，64 位地址已经相当复杂，再加车道可能难以与其他部件协调。NVlink 已经很快了，但造价昂贵，得不偿失，只是跟处理器比起来，内存带宽确实相对太慢了。计算机是一个整体系统，整体大于局部之和。\n\n学生：既然如此，V100 为什么要造出一百倍的计算单元来？\nKayvon：因为大部分深度学习并不是简单的一次性向量运算，而是 读取一次，计算多次。\n\nISPC\nISPC 全称是 Intel SPMD Program Compiler，它是由 Intel 开发的一种编程工具，用于编写单指令多数据（SPMD，Single Program Multiple Data） 风格的并行程序。它特别适合在现代 CPU 和 GPU 上运行高性能并行计算任务。\n\n\n这是一种相当冷门的语言，冷门到你在 Github 和 Stack Overflow 上找不到几个相关东西。使用它的人数可能就是本课程的学习人数乘以开课年限，再加上几百个英特尔相关方向的从业者。\n\n\nISPC：Intel SPMD Program Compiler\nSPMD：Single Program Multiple Data 单程序多数据\n\n\n\nhttps://ispc.github.io/\nhttps://github.com/ispc/ispc\nhttps://pharr.org/matt/blog/2018/04/30/ispc-all\n为什么 C++ 不够快？为什么要设计 ISPC？\n\n\n\nISPC 重写 sinx()回想：一般的 sinx()\n// sinx.hvoid sinx(int N, int terms, float* x, float* result)&#123;    for (int i=0; i&lt;N; i++)    &#123;        float value = x[i];        float numer = x[i] * x[i] * x[i];        int denom = 6; // 3!        int sign = -1;        for (int j=1; j&lt;=terms; j++)        &#123;            value += sign * numer / denom;            numer *= x[i] * x[i];            denom *= (2*j + 2) * (2*j + 3);            sign *= -1;        &#125;      result[i] = value;    &#125;&#125;\n\n它的主函数可能是\n// main.cpp#include &quot;sinx.h&quot;int main(int argc, void** argv)&#123;  int N = 1024;  int terms = 5;  float* x = new float[N];  float* result = new float[N];  // initialize x here  sinx(N, terms, x, result);  return 0;&#125;\n\n现在，看看如何用 ISPC 重写这个程序\n当调用 ispc_sinx()函数时，它并不像常规 C 语言程序一样（调用-返回），它的大致流程是：\n\n调用 ISPC 函数，生成一群 程序实例（program instances）（不是线程 thread）\n程序实例的个数由 programCount （程序计数）决定\n每个程序实例的 programIndex（程序索引）是不同的，以此来区分不同程序实例的任务\n\n\n所有实例同时运行 ISPC 代码\n每个实例都有自己的局部变量副本（代码中的蓝色变量，稍后我们将讨论“uniform”）\n返回时，所有实例都完事了\n\n\n问题：假如 programCount （程序计数）为 8，也就是 8 个程序同时运行，编号为 0 到 7。那么请问，每个程序（比如程序编号为 j 的程序），做哪些元素的运算？\n答：编号为 j 的程序，做 sin(x[i])，其中i mod j = 0\n\n想象一下希尔排序，就是不断变换步长进行插入排序，其中每一轮插入排序做的工作，就是现在这个 ispc 派生的 8 个程序实例所做的工作。它们在空间上（数组上）是 交错执行 的。\n\n另一种方式则是分块执行\n\n\n我们有多种方式实现 SPMD，但如何分配这些派生的 Program Instance，是最好的方式呢？因为 Program Instance 只是 Intel 提出的一个概念罢了，具体到硬件还是要线程来干。\n分配程序实例的 4 种方式：\n\nKayvon：I don’t care.\n是的，这四种方式都是 foreach 的正确有效实现，但具体怎么实现？我不关心。有可能这个任务更适合分块处理，那个任务更适合交错处理，甚至有任务适合单线程处理。总之，全部交给编译器和硬件决定。这就是 foreach。\n\n我们不需要关心 foreach 具体实现的细节，我们只需要 foreach 循环迭代一个东西，剩下的，交给编译器和硬件。\nforeach (i = 0 ... N)&#123;...&#125;\n\n\nKayvon：我们讲了很多概念，也有很多概念性问题被学生提出，这很正常。因为实际情况更加复杂，就像实际硬件会结合超标量、SIMD、多核与硬件多线程等技术一样，ISPC 的 Program Instance（程序实例） 究竟是如何实现的，我们也不必过多关心，或许是自动多线程，或许是自动向量化（向量指令代替标量指令）。或许随着 ISPC 的编译器迭代更新和计算机其他领域的技术突破，未来实现 程序实例 的最优底层方式和细节会有所变化，但无所谓，我们的代码是不变的。\n这种层次结构设计非常非常重要（very very important），在良好的编程系统设计中：既提供高级语法 foreach，也提供自定义实现循环迭代的语法（四种方法）。在大多数情况下，foreach 都会表现得很好，但如果你对自己的程序和机器（软件和硬件）相当了解，想要自定义迭代策略（do it yourself），也完全 ok。\n\n相互独立的迭代？export void shift_negative(  uniform int N,  uniform float* x,  uniform float* y)&#123;  foreach (i = 0 ... N)  &#123;    if (i &gt;= 0 &amp;&amp; x[i] &lt; 0)      y[i-1] = x[i]    else      y[i] = x[i]  &#125;&#125;\n\n这是一个有效的 ispc 程序吗？\n不是。\n当你使用 foreach，代表你默认这些迭代是相互独立的，可以按照任意顺序执行，而不会影响最终结果。但事实上呢？这些迭代的顺序会影响最终的结果，结果是不可预知的。因此，无法乱序执行的迭代不能交给 ispc 编译器自行优化。\n\n这就是竞态条件（race condition）\n\n\n竞态条件（race condition）是指在并发程序中，多个线程或进程对共享资源进行访问和修改时，结果的正确性依赖于访问的顺序。如果不同线程的执行顺序不一致，就可能导致程序的行为不可预测，产生错误结果。\n\nuniform：返回值必须是公共的uniform 关键字：代表所有的 程序实例（Program Instance）\n错误的程序 1export uniform float sum_incorrect_1(  uniform int N,  uniform float* x)&#123;  float sum = 0.0f;  foreach (i = 0 ... N)  &#123;    sum += x[i];  &#125;  return sum;&#125;\n\n这个程序无法通过编译，具体而言，无法通过编译器类型检查。因为 sum 没有被 uniform 修饰，每个 程序实例 持有不同的 sum，没有办法返回一个统一值。\n错误的程序 2那如果加上 uniform 修饰呢？这个程序仍然不会正确运行。它会遇到另一个竞态条件。\nexport uniform float sum_incorrect_2(  uniform int N,  uniform float* x)&#123;  uniform float sum = 0.0f;  foreach (i = 0 ... N)  &#123;    sum += x[i];  &#125;  return sum;&#125;\n\n正确的程序export uniform float sum_incorrect_1(  uniform int N,  uniform float* x)&#123;  uniform float sum;  float partial = 0.0f;  foreach (i = 0 ... N)  &#123;    partial += x[i];  &#125;  // reduce_add() 是 ispc 的跨程序实例标准库函数  sum = reduce_add(partial);  return sum;&#125;\n\nreduce_add() 函如其名，就是做累加的。跟 python 中的 reduce() 一样，只不过它是跨程序实例的。\n这样就得到了正确的并行累加方法，避免了竞态条件。\n案例：三个程序操作系统一般通过软&#x2F;硬件计时器，来周期性地处理各个进程、线程的上下文切换，比如说我的电脑有 8 个硬件线程，在某一时刻，计时器 a 到点了，操作系统就会对硬件说：嘿，硬件，这 8 个线程你去运行吧！在另一时刻，计时器 b 到点了，操作系统经过一些处理和判断后，挑选出新的 8 个线程，继续交给硬件执行。\n\nKayvon：既然你（学生）问了，那我正好有一个 C 语言测试程序（去除了所有编译器优化）。\n\n\n**do_work()**：基准工作函数，空函数，仅用于测试调用开销。\nTest 0（单线程）：在单个线程中调用 do_work() N 次。\nTest 1（大量线程创建与销毁）：为每次 do_work() 调用创建一个新线程，调用后立即销毁，总共 N 次。\nTest 2（线程池）：创建 8 个线程的线程池，共同完成 N 次 do_work() 调用。\n其中，N 大约是十亿.\n\n结果\n\nTest 0（单线程）：0.001667 s\nTest 1（创建大量线程）：13.15 s\nTest 2（线程池）：0.04 s\n\n分析\n\nTest 1 最慢（13.15s）：\n\n频繁创建和销毁线程，涉及大量系统调用和调度开销。\n线程的创建和销毁在操作系统层面涉及 内核上下文切换，开销非常大（数十万 CPU 周期）。\n\n\nTest 2（线程池）比 Test 1 快 333 倍：\n\n线程池 复用 线程，避免了频繁的创建和销毁。\n线程调度仍然存在，但远低于 Test 1。\n\n\nTest 0（单线程）比 Test 2 还要快 23.7 倍：\n\nTest 2 仍然涉及 线程调度，而 Test 0 只是在 同一个线程中执行循环，完全避免了线程切换的开销。\n用户态函数调用 比 线程切换 快得多。\n\n\n\n\nKayvon：不要混淆你在操作系统中学到的知识。操作系统的上下文切换一般需要 数十万周期，硬件多线程的上下文切换只需要 1个周期，它们非常不同！如果你要用操作系统的上下文切换来 隐藏内存访问的延迟，内存访问会在 几百个周期 内完成，但你仍然需要等待 数十万个周期 来切换线程上下文。这毫无意义！所以：概念是相同的，但数量级完全不同。\n\n其四：Parallel Programming Basics\n第四讲：并行编程基础\n\n\n摘要：构建并行程序。在数据并行和共享地址空间模型中并行化程序的过程\n\n\n主题：编写优化并行程序的案例研究\n\nAmdahl’s law加速比计算公式：Sn = (Ws + Wp) / (Ws + Wp/p)\n其中，Ws 表示无法被并行化的部分，Wp 表示该部分可以用 p 个节点进行并行计算。\n当 p 趋于无穷大时，Wp/p 趋于无穷小，该式简化为：(Ws + Wp) / Ws &#x3D; W / Ws。\n其中，W = Ws + Wp。\n\n设并行部分占比 a = (Wp / W) ∈ [0, 1]\n则串行部分占比 Ws / W = (W - Wp) / W = 1 - a\n则加速比 Sn = 1 / (1 - a + a/p)\n则当 p -&gt; ∞ 时，Sn = 1 / (1 - a)\n\n案例：图像处理假如我有两个图片，尺寸都是 N x N。我要做一些图像处理，比如计算所有像素的和。时间复杂度显然是 N^2。\n假如我的机器有 p 个并行处理器（可能是向量、硬件多线程等方式实现的，不作详细讨论）\n策略 1：\n\n并行处理第一个图片\n时间：N^2&#x2F;P\n\n\n串行处理第二个图片\n时间：N^2\n\n\n\n于是我们很容易得到加速比:\n\nSpeedup &lt;= 2n^2 / (n^2 / p + n^2)\nSpeedup &lt;= 2\n\n策略 2：两个图片都并行处理，最后把部分和总起来。\n\n并行处理第一个图片\n时间：N^2&#x2F;P\n\n\n并行处理第二个图片\n时间：N^2&#x2F;P + p\n\n\n\n加速比:\n\nSpeedup &lt;= 2n^2 / (2n^2 / p + p)\n当 N&gt;&gt;P 时，Speedup -&gt; p\n\nAmdahl’s law如果用 s 表示程序中无法并行化部分的占比，在 p 个处理器上的最大加速比为：\nspeedup &lt;= 1 / (s + (1-s)/p )\n\n假设你的程序只有 1%是串行的，另外的 99%能够在 64 核心机器上得到完美优化，最大的加速比也只有四十倍。\n\n那 1% 的串行部分真的开始拖后腿了。\n\n如果我的程序有 10% 无法并行化，我在 64 核心机器上的最大加速比大约是 8 倍。\n现在，如果用一个含有 1.5 亿并行单元的超级计算机上运行你的程序，那你最好把串行部分缩减到 0.00000001%，否则，你可能还不如不用这台计算机。\n\n幸运的是，我们运行的大多数代码都相当容易并行化。\n\n\n所以，就像我说的，在这个课上，理解如何分解问题几乎就像我们在这里做的一样，取决于你编写一个能很好的分解问题的程序。\n\n\nDon’t hope for magic here.\n\n并行程序（分解-分配-编排-映射）\n创建一个并行程序并运行，这个世界发生了什么？\n四个步骤：\n\n分解 Decompositon\n子问题：高维度的任务分解（tasks）\n承担者：程序员（Programmer）\n\n\n分配 Assignment\n并行线程（workers）\n承担者：编译器&#x2F;运行时（Compiler&#x2F;Runtime）\n\n\n编排 Orchestration\n并行程序（通信线程）\n\n\n映射 Mapping\n运行在并行机器上\n\n\n\n这些责任可能由程序员、系统（编译器、运行时、硬件）或两者都承担！\n\n很多时候，我们更想让系统来帮我们完成这些任务，我们不想在优化并行运算上浪费太多时间，我们只想解决实际问题。但有时候，你不得不自己承担这些任务（比如让程序在你有生之年能够运行完）。\n\n分解 Decomposition\n谁负责将程序分解为独立的任务？\n在大多数情况下：程序员\n\n\n顺序程序的自动分解仍然是一个具有挑战性的研究问题（在一般情况下非常困难）\n编译器必须分析程序，确定依赖关系\n如果依赖关系依赖于数据（编译时未知）怎么办？\n\n\n研究人员在简单的循环嵌套上取得了适度的成功\n用于复杂通用代码的“魔法并行编译器”尚未实现\n\nAssignment 分配\nAssigning tasks to workers将任务分配给工人\n\n把“任务”看作是要做的事情\n什么是“工人”？（可能是线程（threads）、程序实例（program instances）、向量通道（vector lanes）等）\n\n\n目标：实现良好的工作负载平衡，减少通信成本\n\n可以静态执行（在应用程序运行之前），也可以在程序执行时动态执行。\n\n尽管程序员通常负责分解（decomposition），但许多 语言/运行时 负责分配（assignment）。\n\n\nISPC 任务动态分配ISPC 运行时（对程序员不可见）分配任务给线程池中的工作线程。\n线程任务分配的实现：在完成当前任务后，工作线程检查任务列表并把下一个未完成的任务分配给自己。\n\n\n有时候，即使你把任务分解为两个部分，这些并行工作单元仍然需要 同步 操作，以确保每个任务只分配给一个单元，并且每个工作单元都能得到下一个任务。\n在之前的三个测试用例中，线程池的版本比单线程要慢，因为我的线程在获取下一个任务时需要 同步\n\nOrchestration 编排\n涉及：\n构建通信\n必要时添加同步以保留依赖关系\n在内存中组织数据结构\n调度任务\n\n\n目标：降低通信&#x2F;同步成本，保持数据引用的局部性，减少开销等。\n机器细节会影响其中许多决策\n如果同步操作很昂贵，程序员可能会更少地使用它\n\n\n\n映射 Mapping\n将“线程”（“工作者”）映射到硬件执行单元\n示例 1：操作系统映射\n例如，将线程映射到 CPU 核心上的硬件执行上下文\n\n\n示例 2：编译器映射\n将 ISPC 程序实例 映射到 向量指令通道（vector instruction lanes）\n\n\n示例 3：硬件映射\n将 CUDA 线程块映射到 GPU 内核（在未来的讲座中讨论）\n\n\n许多有趣的映射决策：\n将相关线程（协作线程）放置在同一核心上（最大限度地提高局部性、数据共享、最大限度地降低通信&#x2F;同步成本）\n将不相关的线程放在同一个核心上（一个可能是带宽有限的，另一个可能计算有限），以更有效地使用机器\n\n\n\n案例：一个并行程序基于二维网格的求解器\n求解器 solver\n求解器是一种数学软件，可能以独立计算机程序的形式或作为软件库，用于“解决”数学问题。求解器以某种通用形式获取问题描述并计算其解。在求解器中，重点是创建一个可以轻松应用于其他类似问题的程序或库。\n\n\n最优解\n就像很多高等函数很难求最大值和最小值，那就只能“一个点一个点尝试”，直到找到一个“极值”，这个值就可以作为局部最优解。\n\n\n收敛\n就像牛顿迭代法求平方根一样，我们不断迭代计算，如果最后两次结果差距越来越小（|f(n)-f(n-1)| &lt; epsilon）直到达到我们所要求的精度差，那么就称这个迭代是 收敛的。\n\n\n\n问题：求解（N+2）x（N+2”网格上的偏微分方程（PDE）\n解决方案使用迭代算法：\n在网格上执行高斯-赛德尔扫描，直到收敛\n\n\n\n求解算法的伪代码如图：\n\n\n任何事情的第一步，当我展示代码时我就是在问你：哪些部分可以并行处理？\n\n难点在于，每个点的计算都依赖于它的四个邻居。而这些邻居有的更新了，有的没更新。\n具体而言，一个点（不是边缘点）的左边和上边位置的值是已经更新了的，右边和下边则没有更新。\n依赖关系是由左上角传递到右下角的。\n步骤 1：确定依赖关系（问题分解阶段）\n\n\n沿对角线有一定的并行性！\n我们可以把每条对角线的运算作为一个 task 来进行任务分解\n缺点：\n在开头和结尾的并行数太低了！\n频繁的同步操作！\n\n\n\n\n且不说我想不想写这种（屎山）代码，这种分解方式：\n\n并行数太少了，根据阿姆达定律，可能性能提升很不明显。\n沿着对角线访问内存，缓存命中率可能很低！\n\n\n\n这种思考是我们需要做的最重要的部分！当我们在今年（2023）作业 4 中做一个小型 Transformer 时，这将成为其中很大一部分。有时候你看着一个程序会想：我真的不想费心去处理这个，这不是一个我会取得很大成功的程序。\n\n选择另一种求解器\n\n你需要修改算法，不能使用原始的高斯-赛德尔算法，而是要找到一种更适合并行化计算的算法！是的，我们需要高斯-赛德尔方法的专业领域知识（而这是并行编程中的一种常见技术）\n\n\n让我们尝试用新的算法来获得更好的并行化支持！\n\n新方法：红黑色块\n红黑色块不断地交替进行运算，一轮红、一轮黑，并行性很好！\n\n虽然实际上，这个算法收敛速度更慢。但，我们似乎没别的办法了\n分块还是交错？\n现在，有一个新的问题，假如我们按行分配任务，假设分给 4 个并行单元，\n\n分块分配：把矩阵平均分成四大块，每块交给一个单元处理\n交错分配：按行号 i 分配任务，j = i mod 4，那么第 i 行分给计算单元 j\n\n注意到，分块的方式减少了不同单元之间的数据交换发生，它们只有边界的行才需要依赖相邻单元的数据。而在交错分配方式中，每一行都要依赖相邻的其他单元的数据。\n所以，分块的方式看起来更不错。请注意，我们在之前的 sinx 程序中的最佳分配方式是不同的。情况不同，结论就不同！\n两种方式：去考虑编写程序\n\n数据并行思考\n完全不考虑多线程和总体并行化，只是考虑任务的并行化\n\n\nSPMD &#x2F; 共享地址空间\n这是我的所有工人，然后这是他们如何进行通信并解决问题\n\n\n\n求解器的数据并行化表达\n\n[!NOTE]这是伪代码，我们现在只是在抽象地思考问题。我们先跳出 ISPC、SPMD、SIMD 等具体的东西。\n\n最初，代码看起来是顺序迭代的，但我们稍加改动\n\n分解：\nfor_all (red cells (i, j))，遍历红色点而不是全部点\n\n\n分配：？？\n编排：\n内置通信原语：reduceAdd\nfor_all 块的结束是隐式等待所有 workers 返回顺序控制\n\n\n\n求解器的共享地址空间（使用 SPMD 线程）写法我们有一个地址空间，我们不得不用一些手段来进行同步（比如锁和屏障）。\n\n程序员负责同步\n常见同步原语：\n锁（提供互斥）：在不稳定的区域，一次只能有一个线程\n屏障：等待线程到达这一点\n\n\n\n\n\n不同的程序实例有相同的代码和地址空间\n但不同程序实例的 id 是不同的，靠 id 来区分他们的任务\n使用 getThreadId() 获取线程 id。\n在(N+2)*(N+2)网格上，对于 id 为 x 的线程，它分到的行号为 1 + (x*n/p), 1 + ((x+1)\\*n/p)，其中 p 为处理器个数\n\n\n加锁：防止 diff+=myDiff 的竞态条件导致错误\n\n我们需要确保对这个共享变量的修改操作是原子操作\n\n\n具体来说，多线程读写（这里是加和）可能会导致错过一次（或多次）写回\n\n本课程之后会讲解其他原语来解决竞态条件\n\n\n\n\n性能问题：部分和应该在何时进行？（减少同步操作）\n这个代码已经是改进过的版本了，原始代码中没有 myDiff 变量，而是直接在最内层循环对 diff 进行加和，那样会导致过多的同步操作\n\n回想：“如果同步操作很昂贵，程序员可能会更少地使用它”\n\n\n\n\n屏障（Barrier）：\n\n屏障是同步的另一种形式。屏障是一种非常粗粒度的同步框架。\n\n\n所有线程都不能越过一个屏障，直到所有的线程都运行到这个屏障为止。\n\n屏障保证没有线程可以“偷跑”，必须等待大家到齐，一起越过屏障。\n\n\n屏障 1：\n确保所有线程都执行完 diff=0.0，再进行下一轮的 diff 加和。\n如果没有屏障 1，可能某个线程运行非常快，已经计算完毕myDiff 并把它加给了 diff。然而，有的线程可能正准备进行清零 diff=0.0，导致丢失部分和。\n\n\n屏障 2：\n确保执行收敛检查之前，所有的线程都完成了这一轮的算法（最重要的，完成了差错的总和 diff+=mydiff）\n如果没有屏障 2，结果可能不正确。（在 diff+=mydiff 总和完成之前，某个线程就执行了收敛检查，导致判断为收敛）\n\n\n屏障 3：\n确保所有线程执行收敛检查完毕，才执行下一轮的 diff=0.0\n如果没有屏障 3，可能某个线程跑到了下一次循环执行了 diff=0.0，但还有线程正要进行收敛检查，导致判断为收敛。\n\n\n\n\n挑战：能否只用一个屏障来避免这些竞态条件？\n（提示：借鉴上文说到的 myDiff 变量优化思路）\n（提示 2：这些线程在竞争什么？）\n\n\n\n一个屏障\n\n我们在代码中引入了 不必要的依赖，因为我每次迭代都重复使用 一个变量 来实现 多个目的\n\n\n多个目的：\n\n清零 diff = 0.0\n加和 diff += mydiff\n收敛检查 diff/(n*n) &lt; TOLERANCE\n\n\n回想：屏障的作用\n\n屏障 1：隔离 diff = 0.0 和 diff += mydiff\n屏障 2：隔离 diff += mydiff 和 收敛检查\n屏障 3：隔离 收敛检查 和 下一轮的 diff = 0.0\n\n\n\n我们使用多个地址空间，替代原本只有一个的全局变量 diff。\n那么，我们需要几个 diff 呢？\n最朴素的想法是：使用与循环次数相同的 diff 数量。然而，循环的终止条件与迭代次数无关，只取决于收敛与否，因此这个数没法提前确定。那贸然给一个足够大的确定数呢，就太浪费空间了。\n去除屏障 3：\n为了隔离本轮的 收敛检查 和 下一轮的 diff=0.0，至少需要 2 个 diff 交错来使用。（比如奇数次用 diff1，偶数次用 diff2。）这时，我们就避免了下一轮的清零（diff2=0.0）影响本轮的检查（检查 diff1）。\n那屏障 1 此时能否去掉？\n去除屏障 1：\n现在我们有 2 个 diff，假设去掉屏障 1.\n\n本轮使用 diff1 完成收敛检查后，下一轮使用 diff2，执行 diff2=0.0\n如果去掉 屏障1，仍然可能会有线程率先完成计算 diff2 += mydiff，然后接着有慢腾腾的线程才执行 diff2 = 0.0，导致丢失计算信息。\n\n但是，diff2 += mydiff 和 diff2 = 0.0 发生在同一轮次，不管多少个 diff 都解决不了这个问题。因此，我们要 修改代码：\n\n增加 diff3\n修改 diff2 += mydiff 和 diff2 = 0.0，其中一个要使用 diff3\n\n这对不对呢？不妨假设修改了 diff2 = 0.0 为 diff3 = 0.0。我们仍然从唯一的那个屏障开始分析：\n\n某一轮，使用 diff1 完成了收敛检查\n下一轮，执行 diff3 = 0.0，并使用 diff2 += mydiff 计算总和\n显然，三个操作使用三个不同的全局变量，且有一个屏障保证多线程不会相差超过上下两个周期，消除了竞态条件。\n一个问题：diff2 是在什么时候被清零的？\n因为 diff3 = 0.0 和 diff2 += mydiff 发生在同一轮\n也就是说，diff[(i+1) % 3] = 0.0 和 diff[i] += mydiff 发生在同一轮\n因此 diff2 = 0.0 和 diff1 += mydiff 发生在同一轮。\n\n\n\n最终，我们增加了 2 个全局变量，减少了 2 个屏障，获得了性能提升。\n\n其五：Performance Optimization I: Work Distribution and Scheduling\n性能优化 1：工作分配和调度\n\n\n摘要：实现良好的工作分配，同时最小化开销，使用工作窃取来调度 Cilk 程序\n\n高性能编程\n优化并行程序的性能是一个不断迭代的过程，改进 分解 decomposition、分配 assignment 和 编排 orchestration的选择\n关键目标（相互矛盾）\n在可用的执行资源上平衡工作负载\n减少通信（避免停顿）\n减少因为提高并行性、管理分配、减少通信等而执行的额外工作（开销）。\n\n\n\n\n[!TIP]Always implement the simplest solution first, then measure performance to determine if you need to do better.\n始终先实施最简单的解决方案，然后衡量性能以确定是否需要做得更好。\n\n\nKayvon：因为在一些编程作业中，很多学生一开始就奔着复杂化、并行化、“优化”去了，他们花费大部分时间来研究讲义、研究各种技术，构造一个相当复杂的方案。最后，在作业截止前三四天，他们说“只需要把它编码出来，能运行，它就会表现得很好”。结果往往是，复杂的方案比简单的方案更慢。\n\n平衡工作负载理想情况下：在程序执行期间，所有处理器都在进行计算（他们同时（simultaneously）进行计算，同时（at the same time）完成各自的工作）\n\n假设有 4 个处理器处理 4 个任务，花费时间为：\np1: 1 mins\np2: 1 mins\np3: 1 mins\np4: 2 mins\n\n\n\np4 花费多一倍的时间，所以按照阿姆达定律：\n\n加速比 Sn = 1 / (1 - a + a/p)，\n其中 a = 4 / 5 = 0.8（可串行化部分占比）\n其中 p = 4（4 个处理器）\n所以 Sn = 1 / (1 - 0.8 + 0.8/4) = 1/0.4 = 2.5\n\n如果我们能完全平均分配任务，加速比应当是 4 倍。\n静态分配（Static assignment）\n分配不一定发生在编译时（compile-time）\n之所以叫 静态，是因为 工作（work） 量和 工作者 数量是确定的\n分配还取决于运行时参数：输入数据的规模、线程数，等等。\n\n\n回忆编程作业 1，程序 1：为每个线程分配相同数量的网格单元 – 学生探索不同的静态工作分配给工人\n静态赋值的优点：执行赋值的简单、基本上为零的运行时开销(在本例中：实现赋值的工作有点像索引数学)\n\n\n\n平均区域划分\n分形划分\n交错分配\n\n什么时候静态分配更适用？\n\n当工作的成本(执行时间)和工作量是可预测的时候，允许程序员提前制定一个好的分配（assignment）\n当工作是可预测的，但并非所有工作都有相同的成本时\n当执行时间的统计数据是可预测的（例如，平均成本相同）\n\n“半静态”分配\n近期的工作成本是可以预测的\nidea：最近的过去可以很好地预测不久的将来\n\n\n应用程序定期分析其执行情况并重新调整分配\n对于重新调整之间的间隔，分配是“静态的”\n\n\n粒子模拟：当粒子在模拟过程中移动时，将粒子重新分配给工作者\n自适应网格：网格随着对象移动或对象上的流动而变化，模拟过程但变化缓慢\n\n\n","categories":["学习"],"tags":["学习","笔记"]}]